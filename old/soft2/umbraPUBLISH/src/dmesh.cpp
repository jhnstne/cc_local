/*
  File:          dmesh.cpp
  Author:        J.K. Johnstone 
  Created:	 8 April 2003 (from umbra.cpp)
  Last Modified: 8 April 2003 
  Purpose:       Compute the discontinuity mesh of a scene of curves.
		 Generalizes umbra.cpp, a discontinuity mesh concentrating
		 on the regions invisible or partially visible to the light.
  Sequence:	 5th in a sequence (interpolate, tangCurve, bitang, umbra, dmesh)
  Input: 	 k 2d polygons, implicitly defining k interpolating cubic 
  		 Bezier curves: the boundary of the objects in the scene.
  History: 	 
*/

#include <GL/glut.h>
#include <GL/glu.h>
#include <fstream.h>
#include <iostream.h>
#include <math.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <string>
using std::string;
#include <time.h>

#include "AllColor.h"
#include "Miscellany.h"		
#include "Vector.h"		
#include "MiscVector.h"		
#include "BezierCurve.h"	
#include "TangCurve.h"		// CommonTangent, intersect, draw, visible
#include "UmbralBitang.h"

#define PTSPERBEZSEGMENT 10      // # pts to draw on each Bezier segment

static char *RoutineName;
static void usage()
 {
  cout << "Build the discontinuity mesh of a smooth 2d scene." << endl;
  cout << "Usage is " << RoutineName << endl;
  cout << "\t[-d display density of Bezier segment] (default: 10)" << endl;
  cout << "\t[-e eps] (accuracy at which intersections are made: default .001)" << endl;
  cout << "\t[-s #] (obstacle that has refining umbral bitangent animated: 1<=n<=nOb [default: 1])" << endl;
  cout << "\t[-u #] (which umbral bitangent to animate: 0 or 1 [default: 0])" << endl;
  cout << "\t[-r #] (radius of bounding room; default 2)" << endl;
  cout << "\t[-h] (this help message)" << endl;
  cout << "\t <file>.pts" << endl;
 }

static GLfloat   transxob, transyob, zoomob;
static GLboolean leftMouseDown=0;
static GLboolean middleMouseDown=0;
static GLboolean firstx=1,firsty=1;	// first MOUSEX (MOUSEY) reading?
static int	 oldx,oldy;		// previous value of MOUSEX and MOUSEY
static GLboolean DRAWBITANG=0;		// draw bitangents?
static GLboolean DRAWONEBITANG=0;	// draw one bitangent at a time?
static GLboolean DRAWOTANG=0;		// draw outer bitangents?
static GLboolean DRAWITANG=0;		// draw inner bitangents?
static GLboolean DRAWPTANG=0;		// draw piercing bitangents?
static GLboolean DRAWMAXUMBRA=0;	// draw maximal umbra?
static GLboolean DRAWLOCALFRONTUMBRA=0;	// draw local front umbrae?
static GLboolean DRAWGLOBALFRONTUMBRA=0;// draw global front umbra?
static GLboolean DRAWLOCALBACKUMBRA=0;	// draw local back umbrae?
static GLboolean DRAWGLOBALBACKUMBRA=0;	// draw global back umbra?
static GLboolean UMBRAFILLED=0;		// draw global umbra filled?
static GLboolean LABELFRONTUMBRA=0;	// label front umbra with 'u'?
static GLboolean LABELBACKUMBRA=0;	// label back umbra with 'u'?
static GLboolean SHADEFRONTUMBRA=0;	// shade local front umbra?
static GLboolean LABELOBJ=1;		// label the first obstacle A?
static GLboolean ANIMATEINNERSWEEP=0;	// animate inner-sweeping umbral bitangent?
static GLboolean ANIMATEOUTERSWEEP=0;	// animate outer-sweeping umbral bitangent?
static GLboolean DRAWINNERUMBTANG=0;	// draw inner umbral bitangents?
static GLboolean DRAWOUTERUMBTANG=0;	// draw outer umbral bitangents?
static GLboolean ONLYFIRST=0;		// only draw bitangents/umbrae for 1st obstacle?

Array<BezierCurve2f> 	obstacle;	// interpolating cubic Bezier curves
V2fArr			centroid;	// object centroids
Array<TangentialCurve>  obduala;	// associated tangential a-curves
Array<TangentialCurve>  obdualb;	// associated tangential b-curves
Array<CommonTangentArr> bitang;		// bitangents between curves and light
					// curve i/j bitangents are stored in 
					// index i*obstacle.getn() + j
					// (0 is the light)
int 			nextbitang=0;	// counter for cycling thru bitangents					
int 			nextcurve=1;	// another counter for same purpose
float 			radiusRoom=2;	// radius of bounding room's square (which is centered at origin)
Polygon2f		room;		// bounding room
Array<UmbralBitangArr>  outer;		// outer bitangents for each obstacle
					// to light, 2 per obstacle
Array<UmbralBitangArr>  inner;		// inner bitangents for each curve,
					// stored like bitang;
					// both [i*nOb+j] and [j*nOb+i] are stored
					// even though these are equivalent (for elegance in replaceByInner)
Array<UmbralBitangArr>  pierce;		// piercing bitangents for each curve,
					// stored like inner but arbitrary # per obstacle
					// in [i*nOb+j], obstacle[i] is dominant
					// that is, bitangent pierces obstacle[i]
Array<UmbralBitangArr>  umbTangInner;	// global umbral bitangents 
					// generated by inner sweep,
					// 2 for each obstacle
Array<UmbralBitangArr>  umbTangOuter;	// global umbral bitangents 
					// generated by outer sweep,
					// 2 for each obstacle
Array<Polygon2f>	umbra;		// (global) umbral polygon (bounded by room) for each obstacle
Array<Polygon2f>	localUmbra;	// (local) umbral polygon (bounded by room) for each obstacle
Polygon2f		maxUmbra;	// maximal umbral polygon (bounded by room) for first obstacle
int 			specialOb=1;	// animation of refinement of umbral bitangent
					// will be performed for obstacle[specialOb!=0]
BezierCurve2f		specialHodo;	// hodograph of obstacle[specialOb]					
BezierCurve2f		lightHodo;	// hodograph of light
int			specialUmb=0;	// index of umbral bitangent on specialOb to animate
UmbralBitang		specialUmbTang; // the umbral bitangent being animated
int 			nRefined;	
float 			tAnimate;	// present parameter for sweeping tangent
// int			pause=100;	// pause this many steps in animation
int 			pause=1;	// flag: are you pausing in sweep animation?
float colour[7][3] = {{0,0,0}, {1,0,0}, {0,0,1}, {0,1,0}, {1,0,1}, {0,1,1}, {1,1,0}};
int			obstacleWin;	// primal window identifier 
int       		nPtsPerSegment = PTSPERBEZSEGMENT;

/******************************************************************************/
/******************************************************************************/

void gfxinit(void)
{
  glClearColor (1.0, 1.0, 1.0, 1.0);

  glEnable (GL_BLEND);				
  glBlendFunc (GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);
  glEnable (GL_LINE_SMOOTH);			
  glHint (GL_LINE_SMOOTH_HINT,  GL_FASTEST);
  glEnable (GL_POINT_SMOOTH);
  glHint (GL_POINT_SMOOTH_HINT, GL_FASTEST); 
  glPointSize (6.0);

  transxob = transyob = 0.0;
  zoomob = .85;
}

/******************************************************************************/
/******************************************************************************/

void reshape(GLsizei w, GLsizei h)
{
  glViewport(0, 0, w, h);
  glMatrixMode(GL_PROJECTION);
  glLoadIdentity();
  glOrtho(-2.0*(GLfloat)w/(GLfloat)h, 2.0*(GLfloat)w/(GLfloat)h, -2.0, 2.0, -1000.,1000.);
  glMatrixMode(GL_MODELVIEW);
  glLoadIdentity();
}

/******************************************************************************/
/******************************************************************************/

void visibility (int status)
{
  if (status != GLUT_VISIBLE)
    glutIdleFunc (NULL);
}

/******************************************************************************/
/******************************************************************************/

void mouse (int button, int state, int x, int y)
{
  switch (button) {
  case GLUT_LEFT_BUTTON:
	switch (state) {
	case GLUT_DOWN: 
 	  leftMouseDown = firstx = firsty = 1;
	  glutSetCursor (GLUT_CURSOR_UP_DOWN); break;
	case GLUT_UP: 
	  leftMouseDown = 0;
	  glutSetCursor (GLUT_CURSOR_INHERIT); break;
	default: break;
	}
	break;
  case GLUT_MIDDLE_BUTTON:
	switch (state) {
	case GLUT_DOWN:
	  middleMouseDown = firstx = firsty = 1; 
	  glutSetCursor (GLUT_CURSOR_CYCLE); break;
	case GLUT_UP: 		
	  middleMouseDown = 0; 
	  glutSetCursor (GLUT_CURSOR_INHERIT); break;
	default: break;
	}
	break;
  default: break;
  }
}

/******************************************************************************/
/******************************************************************************/

void motionob (int x, int y)
{
  if (leftMouseDown && !middleMouseDown)	   
   {
    if (firstx)  firstx=0; else zoomob -= (float).01*(x-oldx);
    if (zoomob < 0.0) zoomob = 0.0;
   }
  else if (leftMouseDown && middleMouseDown)
   {
    if (firstx)  firstx=0; else transxob += .01*(x-oldx); /* TRANSLATION: X */
    if (firsty)  firsty=0; else transyob += .01*(y-oldy); /* TRANSLATION: Y */
   }
  oldx = x;  
  oldy = y;
  glutPostRedisplay();
}

/******************************************************************************/
/******************************************************************************/

void keyboard (unsigned char key, int x, int y)
{
  switch (key) {
  case 27:	exit(1); 				break;	// ESCAPE
  case '1':	DRAWBITANG = !DRAWBITANG;		break;
  case '2':	DRAWOTANG = !DRAWOTANG;		break;
  case '3':     DRAWLOCALBACKUMBRA  = !DRAWLOCALBACKUMBRA;	break;
  case '4':     DRAWITANG = !DRAWITANG;		break;
  case '5': 	DRAWGLOBALBACKUMBRA = !DRAWGLOBALBACKUMBRA;	break;
  case '6':	ANIMATEINNERSWEEP = !ANIMATEINNERSWEEP;		
  		if (ANIMATEINNERSWEEP)
		 {
		  specialUmbTang = umbTangInner[specialOb][specialUmb];
		  tAnimate = specialUmbTang.tRefine[0]; 
		  nRefined = 1;
		 }
		 					break;
  case '7':	ANIMATEOUTERSWEEP = !ANIMATEOUTERSWEEP;		
  		if (ANIMATEOUTERSWEEP)
		 {
		  specialUmbTang = umbTangOuter[specialOb][specialUmb];
		  tAnimate = specialUmbTang.tRefine[0];
		  nRefined = 1;
		 }					break;
  case '8':	DRAWINNERUMBTANG = !DRAWINNERUMBTANG; 	break;						
  case '9':	DRAWOUTERUMBTANG = !DRAWOUTERUMBTANG; 	break;						
  case '0': 	UMBRAFILLED = !UMBRAFILLED;		break;
  case ' ':	pause = 0;  /* stop pausing */		break;
  case 8:	nextbitang = mod(nextbitang-1, bitang[1].getn()); break; // BACKSPACE
  case 9:	nextbitang++;
  		if (nextbitang == bitang[nextcurve].getn())
		 {
		  nextbitang = 0; 
		  nextcurve++;
		  while (nextcurve < bitang.getn() && 
		  	 bitang[nextcurve].getn() == 0) 
		    nextcurve++;
		  if (nextcurve == bitang.getn()) nextcurve = 1;
		 } 	break;	// TAB
  case 'b': 	if (!DRAWLOCALBACKUMBRA)		// turn local umbra on/off
   		 {
		  DRAWLOCALBACKUMBRA = 1; DRAWGLOBALBACKUMBRA = 0;
		 }
		else 
		 {
		  DRAWLOCALBACKUMBRA = 0; DRAWGLOBALBACKUMBRA = 0; 
		 }
		 					break;
  case 'B': 	if (!DRAWGLOBALBACKUMBRA)		// turn global umbra on/off
   		 {
		  DRAWGLOBALBACKUMBRA = 1; DRAWLOCALBACKUMBRA = 0;
		 }
		else 
		 {
		  DRAWGLOBALBACKUMBRA = 0; DRAWLOCALBACKUMBRA = 0;
		 }
		 					break;
  case 'f':	if (!DRAWLOCALFRONTUMBRA)
   		 {
		  DRAWLOCALFRONTUMBRA = 1; DRAWGLOBALFRONTUMBRA = 0;
		 }
		else 
		 {
		  DRAWLOCALFRONTUMBRA = 0; DRAWGLOBALFRONTUMBRA = 0; 
		 }
		 					break;
  case 'F': 	if (!DRAWGLOBALFRONTUMBRA)
   		 {
		  DRAWGLOBALFRONTUMBRA = 1; DRAWLOCALFRONTUMBRA = 0;
		 }
		else 
		 {
		  DRAWGLOBALFRONTUMBRA = 0; DRAWLOCALFRONTUMBRA = 0;
		 }					break;
  case 'l':	LABELFRONTUMBRA = !LABELFRONTUMBRA;	break;
  case 'L':     LABELBACKUMBRA = !LABELBACKUMBRA;	break;
  case 's':	SHADEFRONTUMBRA = !SHADEFRONTUMBRA;	break;
  case 'r': 	UMBRAFILLED = !UMBRAFILLED;		break;
  case 'm':	DRAWMAXUMBRA = !DRAWMAXUMBRA;		break;
  case 'o':	DRAWOTANG = !DRAWOTANG;			break;
  case 'i':	DRAWITANG = !DRAWITANG;			break;
  case 'p':	DRAWPTANG = !DRAWPTANG;			break;
  default:      break;
  }
  glutPostRedisplay();
}

/******************************************************************************/
/******************************************************************************/

void menuOb (int value)
{
  switch (value) {
  case 1:	DRAWBITANG = !DRAWBITANG;		break;
  case 2:	DRAWOTANG = !DRAWOTANG;			break;
  case 3: 	DRAWONEBITANG = !DRAWONEBITANG;		break;
  case 4:     	DRAWITANG = !DRAWITANG;			break;
  case 14:     	DRAWPTANG = !DRAWPTANG;			break;
  case 11: 	if (!DRAWLOCALBACKUMBRA)		// turn local umbra on/off
   		 {
		  DRAWLOCALBACKUMBRA = 1; DRAWGLOBALBACKUMBRA = 0;
		 }
		else 
		 {
		  DRAWLOCALBACKUMBRA = 0; DRAWGLOBALBACKUMBRA = 0; 
		 }
		 					break;
  case 5: 	if (!DRAWGLOBALBACKUMBRA)		// turn global umbra on/off
   		 {
		  DRAWGLOBALBACKUMBRA = 1; DRAWLOCALBACKUMBRA = 0;
		 }
		else 
		 {
		  DRAWGLOBALBACKUMBRA = 0; DRAWLOCALBACKUMBRA = 0;
		 }
		 					break;
  case 15:	if (!DRAWLOCALFRONTUMBRA)
   		 {
		  DRAWLOCALFRONTUMBRA = 1; DRAWGLOBALFRONTUMBRA = 0;
		 }
		else 
		 {
		  DRAWLOCALFRONTUMBRA = 0; DRAWGLOBALFRONTUMBRA = 0; 
		 }
		 					break;
  case 16: 	if (!DRAWGLOBALFRONTUMBRA)
   		 {
		  DRAWGLOBALFRONTUMBRA = 1; DRAWLOCALFRONTUMBRA = 0;
		 }
		else 
		 {
		  DRAWGLOBALFRONTUMBRA = 0; DRAWLOCALFRONTUMBRA = 0;
		 }					break;
  case 6:	ANIMATEINNERSWEEP = !ANIMATEINNERSWEEP;		
  		if (ANIMATEINNERSWEEP)
		 {
		  specialUmbTang = umbTangInner[specialOb][specialUmb];
		  tAnimate = specialUmbTang.tRefine[0]; 
		  nRefined = 1;
		 }
		 					break;
  case 7:	ANIMATEOUTERSWEEP = !ANIMATEOUTERSWEEP;		
  		if (ANIMATEOUTERSWEEP)
		 {
		  specialUmbTang = umbTangOuter[specialOb][specialUmb];
		  tAnimate = specialUmbTang.tRefine[0]; 
		  nRefined = 1;
		 }
		 					break;
  case 8:	DRAWINNERUMBTANG = !DRAWINNERUMBTANG; 	break;						
  case 9:	DRAWOUTERUMBTANG = !DRAWOUTERUMBTANG; 	break;
  case 0: 	UMBRAFILLED = !UMBRAFILLED;		break;
  case 12:	DRAWMAXUMBRA = !DRAWMAXUMBRA;		break;
  case 13: 	LABELOBJ = !LABELOBJ;			break;
  case 10:	ONLYFIRST = !ONLYFIRST;			break;
  case 19:	SHADEFRONTUMBRA = !SHADEFRONTUMBRA;	break;
  default:   					break;
  }
  glutPostRedisplay();
}

/******************************************************************************/
/******************************************************************************/
/*
void drawLocalUmbra (UmbralBitangArr &ut)
{
  glBegin(GL_LINE_STRIP);
//  glBegin(GL_POLYGON);
  glVertex2f (ut[0].umbraOb[0],      ut[0].umbraOb[1]);
  glVertex2f (ut[0].umbraExtreme[0], ut[0].umbraExtreme[1]);
  int coord1 = (fabs(ut[0].umbraExtreme[0]) == radiusRoom ? 0 : 1);
  int coord2 = (fabs(ut[1].umbraExtreme[0]) == radiusRoom ? 0 : 1);
  if (coord1 != coord2)		// round the corner
    if (coord1 == 0)
         glVertex2f (ut[0].umbraExtreme[coord1], ut[1].umbraExtreme[coord2]);
    else glVertex2f (ut[1].umbraExtreme[coord2], ut[0].umbraExtreme[coord1]);
  glVertex2f (ut[1].umbraExtreme[0], ut[1].umbraExtreme[1]);
  glVertex2f (ut[1].umbraOb[0],      ut[1].umbraOb[1]);
  glEnd();
}
*/
/******************************************************************************/
/******************************************************************************/

void displayOb ()
{
  int i,j,k;
  glClear (GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
  glPushMatrix();
  glTranslatef (transxob, transyob, 0);
  glScalef  (zoomob, zoomob, zoomob);
//  glPolygonMode (GL_FRONT_AND_BACK, GL_LINE);
  int nOb = obstacle.getn();
  
  glColor3fv (Red);			// bounding room
  room.draw(1);

  if (DRAWMAXUMBRA)			// maximal size of A's umbra is bounded
   {					// by late inner bitangents of A and L
    glColor3fv (DimGrey);
    maxUmbra.draw(UMBRAFILLED ? 2 : 3);
   } 
  if (DRAWLOCALBACKUMBRA)			// invisible region
   {
    glColor3fv (DimGrey);
    for (i=1; ONLYFIRST ? i<2 : i<nOb; i++)
      {
	glBegin(GL_LINES);
	glVertex2f (outer[i][0].umbraOb[0],      outer[i][0].umbraOb[1]);
	glVertex2f (outer[i][0].umbraExtreme[0], outer[i][0].umbraExtreme[1]);
	glVertex2f (outer[i][1].umbraOb[0],      outer[i][1].umbraOb[1]);
	glVertex2f (outer[i][1].umbraExtreme[0], outer[i][1].umbraExtreme[1]);
	glEnd();
      }
   }
  if (DRAWGLOBALBACKUMBRA)
   {
    for (i=1; ONLYFIRST ? i<2 : i<nOb; i++)
     {
      glColor3fv (DimGrey);		
      umbra[i].draw(UMBRAFILLED ? 2 : 1);
//    drawLocalUmbra (umbTangInner[i]);
      if (!UMBRAFILLED)
       {
        glLineWidth (3.0);
        glColor3fv (White);
        glBegin(GL_LINES);
        glVertex2f (umbTangInner[i][0].umbraOb[0], umbTangInner[i][0].umbraOb[1]); 
        glVertex2f (umbTangInner[i][1].umbraOb[0], umbTangInner[i][1].umbraOb[1]);
        glEnd();
        glLineWidth (1.0);
       }
     }
   }
  if (DRAWLOCALFRONTUMBRA)
   {
    glColor3fv (DimGrey);
    for (i=0; i<nOb; i++)
      for (j=0; j<nOb; j++)
        for (k=0; k<pierce[i*nOb+j].getn(); k++)
	  pierce[i*nOb+j][k].drawObExtreme();
   }
  glColor3fv (colour[0]);		// light
  glLineWidth(3.0);
  obstacle[0].draw();
  glLineWidth(1.0);
  if (LABELOBJ)                         // label the objects
   {
     for (i=0; i<nOb; i++)
       {
	 glRasterPos2f (centroid[i][0], centroid[i][1]);
	 char num[2];  itoa (i, num);
	 glutBitmapCharacter(GLUT_BITMAP_9_BY_15, num[0]);
       }
   }
  if (LABELFRONTUMBRA)
   {
    glColor3fv (Black);	// 'U' next to each front umbral bitangent
    for (i=0; i<nOb; i++)
      for (j=0; j<nOb; j++)
        for (k=0; k<pierce[i*nOb+j].getn(); k++)
	  pierce[i*nOb+j][k].labelFrontUmbra(obstacle);
   }
  if (LABELBACKUMBRA)
   {
    for (i=1; ONLYFIRST ? i<2 : i<nOb; i++)	// 'U' in each local back umbra
     {
      V2f c;
      localUmbra[i].centroid(c);
      glRasterPos2f (c[0], c[1]);
      glutBitmapCharacter (GLUT_BITMAP_TIMES_ROMAN_10, 'u');
     }
//    penumbra is harder, because inner boundary is jagged, so delay 
   }
  if (SHADEFRONTUMBRA)		// implicitly assuming a pseudoconvex region
   {
    glColor3fv (Black);
//    for each piercing tangent defining a region of the local front umbra
//      shade the region defined by its intermediate segment
      
   }
  for (i=1; i<nOb; i++)		// obstacles (drawn at end, so that they
   {				// overwrite the global umbra whiteout hack)
    glColor3fv (colour[i%7]);
    obstacle[i].draw(); 
   }
  if (DRAWONEBITANG)
   {
    glColor3fv (Black);
    bitang[nextcurve][nextbitang].draw (obstacle);
   }
  else if (DRAWBITANG)
   {
    glColor3fv (Black);
    for (i=0; i<nOb; i++)
      for (j=i+1; j<nOb; j++)
        for (k=0; k<bitang[i*nOb+j].getn(); k++)
	  bitang[i*nOb+j][k].draw (obstacle);
   }
  if (DRAWOTANG)			// outer bitangents
   {
//    glLineWidth(3.0);
    glColor3fv (Black);
    for (i=1; ONLYFIRST ? i<2 : i<nOb; i++)
      for (j=0; j<2; j++)
       {
        outer[i][j].drawObExtreme();
	outer[i][j].draw (obstacle);
       }
//    glLineWidth(1.0);
   }
  if (DRAWITANG)			// inner bitangents
   {
    glColor3fv (Red);
    for (i=0; i<nOb; i++)
      for (j=i+1; j<nOb; j++)
        for (k=0; k<2; k++)
	 {
	  inner[i*nOb+j][k].drawObExtreme();
	  inner[i*nOb+j][k].draw (obstacle);
	 }
   }
  if (DRAWPTANG)			// piercing bitangents
   {
    glColor3fv (Blue);
    for (i=0; i<nOb; i++)
      for (j=0; j<nOb; j++)
        for (k=0; k<pierce[i*nOb+j].getn(); k++)
	 {
	  pierce[i*nOb+j][k].drawObExtreme();
	  pierce[i*nOb+j][k].draw(obstacle);
	 }
   }
  if (DRAWINNERUMBTANG)			// inner umbral bitangents
   {
    glColor3fv (Green);
    for (i=1; i<nOb; i++)
      for (j=0; j<2; j++)
        umbTangInner[i][j].draw (obstacle);
   }
  if (DRAWOUTERUMBTANG)			// outer umbral bitangents
   {
    glColor3fv (Blue);
    for (i=1; i<nOb; i++)
      for (j=0; j<2; j++)
        if (!umbTangOuter[i][j].abandon)
          umbTangOuter[i][j].draw (obstacle);
   }
  if (ANIMATEINNERSWEEP)   // animate the inner sweep of the umbral bitangent
   { 	
    glColor3fv (Black);
    if (pause) glLineWidth(3.0);
    obstacle[specialOb].drawTangent (tAnimate, specialHodo, 1);
    if (pause) glLineWidth(1.0);
    if (nRefined < specialUmbTang.nRefine)	// not finished
     {
      if (pause==0) tAnimate+=.001;		// refine the bitangent
//      else 	    pause--;
      if (tAnimate > specialUmbTang.tRefine[nRefined])
       {
	tAnimate = specialUmbTang.tRefine[nRefined];
        nRefined++;
//	pause = 100;
	pause = 1;
       }
     }
   }
  if (ANIMATEOUTERSWEEP)   // animate the outer sweep of the umbral bitangent
   { 	
    glColor3fv (Black);
    if (pause) glLineWidth(3.0);
    obstacle[0].drawTangent (tAnimate, lightHodo, 1);
    if (pause) glLineWidth(1.0);
    if (nRefined < specialUmbTang.nRefine)	// not finished
     {
      if (pause==0) tAnimate+=.001;		// refine the bitangent
      if (tAnimate > specialUmbTang.tRefine[nRefined])
       {
	tAnimate = specialUmbTang.tRefine[nRefined];
        nRefined++;
	pause = 1;
       }
     }
   }
     
  glPopMatrix();
  glutSwapBuffers ();
  glutPostRedisplay();	// to keep animation running in both windows
}

/******************************************************************************
	Input curves and scale to unit cube.
	This scaling allows infinite lines to be reduced to finite segments.
******************************************************************************/

void inputCurves (char *file, Array<BezierCurve2f> &obstacle)
{
  int i,j;
  ifstream infile;  infile.open(file);  
  V2fArrArr Pt;		// data points, organized into polygons
  read (infile, Pt);
  scaleToUnitSquare (Pt);
  obstacle.allocate(Pt.getn());
  assert (obstacle.getn() < 10); // otherwise curve labeling must be generalized
  centroid.allocate(Pt.getn());
  for (i=0; i<Pt.getn(); i++)
   { 
    obstacle[i].fitClosed (Pt[i]);
    obstacle[i].prepareDisplay (nPtsPerSegment);
    centroid[i].clear();
    for (j=0; j<Pt[i].getn(); j++)  centroid[i] += Pt[i][j];
    centroid[i] /= Pt[i].getn();
   }
}

/******************************************************************************
	Compute clipped tangential a/b-curves.
******************************************************************************/

void buildTangentialCurves (Array<BezierCurve2f> &obstacle)
{
  obduala.allocate(obstacle.getn());  obdualb.allocate(obstacle.getn());
  for (int i=0; i<obstacle.getn(); i++)	
   {
    obduala[i].createA(obstacle[i], i);
// cout << "obduala[" << i << "]:" << endl;  obduala[i].print();    
    obdualb[i].createB(obstacle[i], i);
// cout << "obdualb[" << i << "]:" << endl;  obdualb[i].print();    
   }
}

/******************************************************************************
	Intersect tangential curves to find bitangents.
	Ensure that bitangents are found from light to obstacle
	(i.e., light first so that index1 and param1 of CommonTangent
	refer to the point of bitangency with the light):
	this is needed in outer.
******************************************************************************/

void buildBitangent      (Array<TangentialCurve> &obduala,
		          Array<TangentialCurve> &obdualb,
		          float eps,
		          Array<CommonTangentArr> &bitang)
{
  Array<CommonTangentArr> bitangA;	// bitangents from a-space 
  Array<CommonTangentArr> bitangB;	// bitangents from b-space 
  int nOb = obduala.getn();   
  bitang.allocate(nOb*nOb);  bitangA.allocate(nOb*nOb);  bitangB.allocate(nOb*nOb);
  for (int i=0; i<nOb; i++)
    for (int j=i+1; j<nOb; j++)		// bitangents between i and j
     {
      obduala[i].intersect (obduala[j], bitangA[i*nOb+j], eps);
      obdualb[i].intersect (obdualb[j], bitangB[i*nOb+j], eps); 
      bitang[i*nOb+j].append (bitangA[i*nOb+j], bitangB[i*nOb+j]);
      IntArr foo; 	bitang[i*nOb+j].bubbleSort (foo);
      bitang[i*nOb+j].deleteDuplicate();      
cout << "Bitangents from obstacle " << i << " to obstacle " << j << ":" << endl;
for (int k=0; k<bitang[i*nOb+j].getn(); k++) bitang[i*nOb+j][k].print();  cout << endl;
     }
}

/******************************************************************************
	Filter bitangents down to outer bitangents.
	Only compute between each obstacle and light, not between obstacles.
******************************************************************************/

void buildOuterBitang  (Array<CommonTangentArr> &bitang,
			Array<BezierCurve2f>    &obstacle,
			float eps,
			Array<UmbralBitangArr>  &outer)
{  
  int i,j;
  int nOb = obstacle.getn();
  outer.allocate(nOb); 
  for (i=1; i<nOb; i++)				// each obstacle
   {
    outer[i].allocate(2);
    int npo=0;  V2f umbraOb, umbraExtreme; int ob; float tOb;
    for (j=0; j<bitang[i].getn(); j++)	// each bitangent from light to obstacle
     {
cout << endl << "Bitangent " << j << " of " << bitang[i].getn() << " from obstacle " << i << endl;     
      if (bitang[i][j].outer(obstacle, eps, radiusRoom, umbraOb, umbraExtreme, ob, tOb))
       	outer[i][npo++].create (bitang[i][j], umbraOb, umbraExtreme, ob, tOb);
     }
    assert (npo==2);
    // trim L-outer pair of obstacle[i] if they intersect
    V2f hit;
    if (outer[i][0].intersect (outer[i][1], hit, .001))
     {
      outer[i][0].trim (hit);  // trim umbral bitangents at intersection
      outer[i][1].trim (hit);
     }
   }  
}

/******************************************************************************
	Filter bitangents down to inner bitangents.
	Compute inner bitangents between all pairs of obstacles,
	not just between obstacles and light.
******************************************************************************/

void buildInnerBitang  (Array<CommonTangentArr> &bitang,
			Array<BezierCurve2f>    &obstacle,
			float eps,
			Array<UmbralBitangArr>  &inner)
{  
  int i,j,k;
  int nOb = obstacle.getn();
  inner.allocate(nOb*nOb); 
  for (i=0; i<nOb; i++)
    for (j=i+1; j<nOb; j++)
     {
      inner[i*nOb+j].allocate(2);
      inner[j*nOb+i].allocate(2);
      int npi=0;  V2f umbraOb, umbraExtreme; int ob; float tOb;
      for (k=0; k<bitang[i*nOb+j].getn(); k++)
       {
cout << endl << "Considering bitangent " << k << " between " << i << " and " << j << endl;
bitang[i*nOb+j][k].print();
        if (bitang[i*nOb+j][k].inner (obstacle, eps, radiusRoom, umbraOb, umbraExtreme, ob, tOb))
	 {
	  inner[i*nOb+j][npi].create (bitang[i*nOb+j][k], umbraOb, umbraExtreme, ob, tOb);
	  inner[j*nOb+i][npi++].createReverse (bitang[i*nOb+j][k], umbraOb, umbraExtreme, ob, tOb);
//	  inner[i*nOb+j][npi].createCT   (bitang[i*nOb+j][k]);
//	  inner[j*nOb+i][npi++].createCTReverse (bitang[i*nOb+j][k]);
	 }
       }
//      assert (npi==2);	// violated by maxumbra.pts so temporarily don't check
     }
}

/******************************************************************************
	Filter bitangents down to piercing bitangents.
	Compute piercing bitangents between all pairs of obstacles.
******************************************************************************/

void buildPierceBitang (Array<CommonTangentArr> &bitang,
			Array<BezierCurve2f>    &obstacle,
			float eps,
			Array<UmbralBitangArr>  &pierce)
{  
cout << "Computing piercing bitangents" << endl;
  int i,j,k;
  int nOb = obstacle.getn();
  pierce.allocate(nOb*nOb); 
  for (i=0; i<nOb; i++)			// note: no longer symmetric
    for (j=i+1; j<nOb; j++)
     {
      if (i==0)
        pierce[j*nOb+i].allocate(10);
      else
       {
        pierce[i*nOb+j].allocate(2);
        pierce[j*nOb+i].allocate(2);
       }
      int npp1=0,npp2=0;  V2f umbraOb, umbraExtreme;  int ob; float tOb, tExtreme;
      for (k=0; k<bitang[i*nOb+j].getn(); k++)
       {
cout << endl << "Considering bitangent " << k << " between " << i << " and " << j << endl;
// bitang[i*nOb+j][k].print();
        if (i!=0 && 
	    bitang[i*nOb+j][k].pierce (obstacle, i, j, eps, radiusRoom, umbraOb, umbraExtreme, ob, tOb, tExtreme))
          	pierce[i*nOb+j][npp1++].create (bitang[i*nOb+j][k],     umbraOb, umbraExtreme, ob, tOb, tExtreme);
        if (bitang[i*nOb+j][k].pierce (obstacle, j, i, eps, radiusRoom, umbraOb, umbraExtreme, ob, tOb, tExtreme))
          	pierce[j*nOb+i][npp2++].create (bitang[i*nOb+j][k],     umbraOb, umbraExtreme, ob, tOb, tExtreme);
       }
      pierce[i*nOb+j].shrink(npp1);
      pierce[j*nOb+i].shrink(npp2);
     }
}

/******************************************************************************
	Inner sweep from outer bitangents.
	Umbral bitangent is refined based on intersections with obstacles.

	[Note: we can't move this refinement into a member function of
	UmbralBitang, since it requires inner, which is not declarable
	as the prototype (as an array of an array)!?]
******************************************************************************/

void innerSweep (Array<UmbralBitangArr> &outer,
		 Array<UmbralBitangArr> &inner,
		 Array<BezierCurve2f>   &obstacle,
		 Array<UmbralBitangArr> &umbTangInner)
{
cout << endl << "ENTERING innerSweep" << endl;
  int nOb = obstacle.getn();
  umbTangInner.allocate(nOb);
  for (int i=1; i<nOb; i++)			// each non-light obstacle
   {
cout << "Refining umbral bitangents from obstacle " << i << endl;
    umbTangInner[i].allocate(2);
    for (int j=0; j<2; j++) 			// each umbral bitangent
     {
      umbTangInner[i][j] = outer[i][j];
      umbTangInner[i][j].nRefine = 1;	// 1st position of umbral bitangent
      umbTangInner[i][j].tRefine[0] = umbTangInner[i][j].param2;
cout << "Original tRefine = " << umbTangInner[i][j].param2 << endl;
      int lightDirForward = umbTangInner[i][j].lightDirectionIsForward (obstacle);
cout << "lightDirForward: " << lightDirForward << endl;      
      int done=0;
      while (!done)	// may skip across several obstacles
       {
	done = 1;	// assume that no intersections will be found
        BezierCurve2f earlyUmbTang;	// early part of umbral bitangent
	int success = umbTangInner[i][j].createSegBetweenLandA (obstacle, earlyUmbTang);
		// if success = 0, we have swept past the light so don't worry about further refinement
        for (int k=1; success && done && k<nOb; k++)	// every other obstacle
	  if (k != umbTangInner[i][j].index1 && 
	      k != umbTangInner[i][j].index2)
           {
cout << "Are there intersections with obstacle " << k << "?" << endl;	   
            int nHit; V2fArr foopt;  FloatArr tfoo,btfoo;
            earlyUmbTang.intersectInterior (obstacle[k], nHit, foopt, tfoo, btfoo, .0000001);
	    if (nHit>0)
	     {
	      done = 0;
	      umbTangInner[i][j].replaceByInner (i, k, lightDirForward, 
	      				    	 inner[i*nOb+k], obstacle, radiusRoom);
	     }
           }
       }
cout << endl << "INNER UMBRAL BITANGENT " << j << " OF OBSTACLE " << i << endl;
umbTangInner[i][j].print();
     }
   }
cout << "Exiting innerSweep" << endl;
}

/******************************************************************************
	Outer sweep from L-outer bitangents.
******************************************************************************/

void outerSweep (Array<UmbralBitangArr> &outer,
		 Array<BezierCurve2f>   &obstacle,
		 Array<UmbralBitangArr> &umbTangInner,
		 Array<UmbralBitangArr> &umbTangOuter)
{
cout << endl << "ENTERING outerSweep" << endl;
  int nOb = obstacle.getn();
  umbTangOuter.allocate(nOb);
  for (int i=1; i<nOb; i++)			// each non-light obstacle
   {
cout << "Refining umbral bitangents from obstacle " << i << endl;
    umbTangOuter[i].allocate(2);
    for (int j=0; j<2; j++) 			// each umbral bitangent
     {
      umbTangOuter[i][j] = outer[i][j];
      UmbralBitang G = umbTangInner[i][j];	// already computed
      umbTangOuter[i][j].abandon = 1;	
      umbTangOuter[i][j].nRefine = 1;	// 1st position of umbral bitangent
      umbTangOuter[i][j].tRefine[0] = umbTangOuter[i][j].param1;
cout << "Original tRefine = " << umbTangOuter[i][j].param1 << endl;
      int ADirForward = umbTangOuter[i][j].ADirectionIsForward (obstacle);
cout << "ADirForward: " << ADirForward << endl;
      int done=0;  int first = 1;
      while (!done)	// may skip across several obstacles
       {
	done = 1;
        BezierCurve2f earlyUmbTang; // segment of umbral bitang between light and G
	int success = umbTangOuter[i][j].createSegBetweenLandG (obstacle, first,
					 		  	G, earlyUmbTang);
        if (!success)
	  // we have swept past the umbra bitangent G that we are looking for
	  umbTangOuter[i][j].abandon = 1;	// abandon the sweep

        for (int k=1; success && done && k<nOb; k++)	// every other obstacle
	  if (k != umbTangOuter[i][j].index2)	// index1 is the light
           {
cout << "Are there intersections with obstacle " << k << "?" << endl;	   
            int nHit; V2fArr foopt;  FloatArr tfoo,btfoo;
            earlyUmbTang.intersectInterior (obstacle[k], nHit, foopt, tfoo, btfoo, .0000001);
	    if (nHit>0)
	     {
	      done = 0;
	      umbTangOuter[i][j].abandon = 0;	// sweep is nontrivial
	      umbTangOuter[i][j].replaceByOuter (k, ADirForward, 
	      				    	 outer[k], obstacle, radiusRoom);
	     }
           }
       }
cout << endl << "OUTER UMBRAL BITANGENT " << j << " OF OBSTACLE " << i << endl;
umbTangOuter[i][j].print();
     }
   }
cout << "Exiting outerSweep" << endl;
}

/******************************************************************************
	Define the line L from the umbral bitangent u
	so that ptInside lies inside L.
******************************************************************************/

void defineInsideHalfspace (UmbralBitang &u, V2f &ptInside, Line2f &L)
{
  L.create (u.umbraOb, u.umbraExtreme);
  if (!L.inside (ptInside))		// inside is wrong! swap it
    L.create (u.umbraExtreme, u.umbraOb);
}

/******************************************************************************
	Define the boundary polygon of each obstacle A's umbra, as follows.
	Start with a bounding square (representing the room)
	of radius R centered at the origin.
	R is defined at the command line.
	Intersect this bounding square with the inside of the 
	following halfspaces:
	1) obstacle chord (chord of obstacle connecting points of bitangency
			   with the two inner umbral bitangents of A)
	2) inner umbral bitangent #1 of A
	3) inner umbral bitangent #2 of A
	4) outer umbral bitangent #1 of A
	5) outer umbral bitangent #2 of A
******************************************************************************/

void defineUmbra (Array<BezierCurve2f>   &obstacle,
		  float radiusRoom, Polygon2f &room,
		  Array<UmbralBitangArr> &umbTangInner,
		  Array<UmbralBitangArr> &umbTangOuter,
		  Array<Polygon2f>	 &umbra)
{
  V2fArr roomPt(4); 					// define room
  roomPt[0][0] = radiusRoom; roomPt[0][1] = radiusRoom;
  roomPt[1][0] =-radiusRoom; roomPt[1][1] = radiusRoom;
  roomPt[2][0] =-radiusRoom; roomPt[2][1] =-radiusRoom;
  roomPt[3][0] = radiusRoom; roomPt[3][1] =-radiusRoom;
  room.create (roomPt);
// cout << "Room = " << room << endl;  
  int nOb = obstacle.getn();
  umbra.allocate (nOb);
  for (int i=1; i<nOb; i++)		// each umbra
   {
// cout << endl << "Defining umbral polygon of obstacle " << i << endl;   
    umbra[i] = room;			// start with room
    Line2f L;
    V2f typicalPtOutside;		// typical pt outside present halfspace
	cout << "Clipping by obstacle chord halfspace" << endl;    
    L.create (umbTangInner[i][0].umbraOb, 	// obstacle chord
    	      umbTangInner[i][1].umbraOb);
    obstacle[0].eval (obstacle[0].getKnot(0), typicalPtOutside); // any pt of light
    if (L.inside (typicalPtOutside)) 	// inside is wrong! swap it
      L.create (umbTangInner[i][1].umbraOb, umbTangInner[i][0].umbraOb);
    umbra[i].halfspaceIntersect (L);
cout << "Umbral polygon = " << umbra[i] << endl;

    V2f typicalPtInside;		// typical pt inside present halfspace
    obstacle[i].eval (obstacle[i].getKnot(1), typicalPtInside); // any pt of obstacle

	cout << "Clipping by inner umbral bitangent halfspace #1" << endl;    
    defineInsideHalfspace (umbTangInner[i][0], typicalPtInside, L);
    umbra[i].halfspaceIntersect (L);  
cout << "Umbral polygon = " << umbra[i] << endl;

	cout << "Clipping by inner umbral bitangent halfspace #2" << endl;    
    defineInsideHalfspace (umbTangInner[i][1], typicalPtInside, L);
cout << "L = " << L << endl;    
    umbra[i].halfspaceIntersect (L);
cout << "Umbral polygon = " << umbra[i] << endl;

    if (!umbTangOuter[i][0].abandon)
     {
	cout << "Clipping by outer umbral bitangent halfspace #1" << endl;
      defineInsideHalfspace (umbTangOuter[i][0], typicalPtInside, L);  
      umbra[i].halfspaceIntersect (L);
cout << "Umbral polygon = " << umbra[i] << endl;
     }

    if (!umbTangOuter[i][1].abandon)
     {
	cout << "Clipping by outer umbral bitangent halfspace #2" << endl;    
      defineInsideHalfspace (umbTangOuter[i][1], typicalPtInside, L);
      umbra[i].halfspaceIntersect (L);
cout << "Umbral polygon = " << umbra[i] << endl;
     } 
   }
}

/******************************************************************************/
/******************************************************************************/

void defineLocalUmbra (Array<UmbralBitangArr> &ut, Array<Polygon2f> &localUmbra)
{
  int nOb = obstacle.getn();
  localUmbra.allocate(nOb);
  V2fArr pt;  int nPt;
  for (int i=1; i<nOb; i++)	// each local umbra
   {
    int coord1 = (fabs(ut[i][0].umbraExtreme[0]) == radiusRoom ? 0 : 1);
    int coord2 = (fabs(ut[i][1].umbraExtreme[0]) == radiusRoom ? 0 : 1);
    if (coord1 != coord2) 	// need to round the corner
       pt.allocate(5);
    else pt.allocate(4);
    pt[0] = ut[i][0].umbraOb;
    pt[1] = ut[i][0].umbraExtreme;
    if (coord1 != coord2)		// round the corner
     {
      if (coord1 == 0)
       {
        pt[2][0] = ut[i][0].umbraExtreme[coord1];
        pt[2][1] = ut[i][1].umbraExtreme[coord2];
       }
      else
       { 
        pt[2][0] = ut[i][1].umbraExtreme[coord2];
        pt[2][1] = ut[i][0].umbraExtreme[coord1];
       }
      nPt = 3;
     }
    else nPt = 2;			// don't need to round the corner
    pt[nPt++] = ut[i][1].umbraExtreme;
    pt[nPt++] = ut[i][1].umbraOb;
    localUmbra[i].create(pt);
   }
}

/******************************************************************************
	it = inner bitangents of A and L
******************************************************************************/

void defineMaxUmbra (UmbralBitangArr &it, Polygon2f &maxUmbra)
{
  V2fArr pt;  int nPt;
  int coord1 = (fabs(it[0].umbraExtreme[0]) == radiusRoom ? 0 : 1);
  int coord2 = (fabs(it[1].umbraExtreme[0]) == radiusRoom ? 0 : 1);
  if (coord1 != coord2) 	// need to round the corner
    pt.allocate(5);
  else pt.allocate(4);
  pt[0] = it[0].umbraOb;
  pt[1] = it[0].umbraExtreme;
  if (coord1 != coord2)		// round the corner
   {
    if (coord1 == 0)
     {
      pt[2][0] = it[0].umbraExtreme[coord1];
      pt[2][1] = it[1].umbraExtreme[coord2];
     }
    else
     { 
      pt[2][0] = it[1].umbraExtreme[coord2];
      pt[2][1] = it[0].umbraExtreme[coord1];
     }
    nPt = 3;
   }
  else nPt = 2;			// don't need to round the corner
  pt[nPt++] = it[1].umbraExtreme;
  pt[nPt++] = it[1].umbraOb;
  maxUmbra.create(pt);
}

/******************************************************************************
******************************************************************************/

int main (int argc, char **argv)
{
  int       ArgsParsed=0;
  float     eps = .001;	// accuracy of intersection computation

  RoutineName = argv[ArgsParsed++];
  if (argc == 1) { usage(); exit(-1); }
  while (ArgsParsed < argc)
   {
    if ('-' == argv[ArgsParsed][0])
      switch (argv[ArgsParsed++][1])
      {
      case 'd': nPtsPerSegment = atoi(argv[ArgsParsed++]);	break;
      case 'e': eps = atof(argv[ArgsParsed++]);			break;
      case 's': specialOb = atoi(argv[ArgsParsed++]);		break;
      case 'u': specialUmb = atoi (argv[ArgsParsed++]);		break;
      case 'r': radiusRoom = atof (argv[ArgsParsed++]);		break;
      case 'h': 
      default:	usage(); exit(-1);				break;
      }
   else ArgsParsed++;
  }

	cout << "Inputting curves" << endl;    
  inputCurves(argv[argc-1], obstacle);
    assert (specialOb >= 1 && specialOb < obstacle.getn());
    assert (specialUmb == 0 || specialUmb == 1);
	cout << "Creating hodographs" << endl;    
    specialHodo.createHodograph (obstacle[specialOb]);
    lightHodo.createHodograph   (obstacle[0]);
	cout << "Building tangential curves" << endl;    
  buildTangentialCurves (obstacle);
	cout << "Building bitangents" << endl;    
  buildBitangent (obduala, obdualb, eps, bitang);  
	cout << "Building outer bitangents" << endl;    
  buildOuterBitang (bitang, obstacle, eps, outer);  // just to light
	cout << "Building inner bitangents" << endl;    
  buildInnerBitang (bitang, obstacle, eps, inner); // all pairs
	cout << "Building piercing bitangents" << endl;    
  buildPierceBitang (bitang, obstacle, eps, pierce); // all pairs
	cout << "Inner sweep" << endl;    
  innerSweep (outer, inner, obstacle, umbTangInner);
	cout << "Outer sweep" << endl;    
  outerSweep (outer, obstacle, umbTangInner, umbTangOuter);
  	cout << "Defining umbral polygons" << endl;
  defineUmbra (obstacle, radiusRoom, room, umbTangInner, umbTangOuter, umbra);
  defineLocalUmbra (outer, localUmbra);
  defineMaxUmbra (inner[1], maxUmbra);
cout << "maxUmbra = " << maxUmbra << endl;
  
  /************************************************************/

  glutInit (&argc, argv);
  glutInitDisplayMode (GLUT_RGB | GLUT_DOUBLE);
  int titleht = 20; 	// top titlebar is 20 units high
  //  int xleft    = 164;		// x-coord of lefthand side for small windows
  //  int xsize = 400, ysize = 400;	// small windows
  int xleft = 0;	// x-coord of lefthand side for large windows
  int xsize = 600, ysize = 600;		// large windows

  glutInitWindowPosition (xleft,titleht);		// primal window
  glutInitWindowSize (xsize,ysize);
  char titlebar[100]; 
  strcpy (titlebar, "Umbra (");  
  strcat (titlebar, argv[argc-1]);  strcat (titlebar, ")");
  obstacleWin = glutCreateWindow (titlebar);
  glutDisplayFunc (displayOb);
  glutKeyboardFunc (keyboard);
  glutMouseFunc (mouse);
  glutMotionFunc (motionob);
  glutVisibilityFunc (visibility);
  glutReshapeFunc (reshape);
  gfxinit();
  glutCreateMenu (menuOb);
  glutAddMenuEntry ("Bitangents", 				1);
  glutAddMenuEntry ("One bitangent at a time",			3);
  glutAddMenuEntry ("Outer bitangents [o]",    			2);
  glutAddMenuEntry ("Inner bitangents [i]",    			4);
  glutAddMenuEntry ("Piercing bitangents [p]",			14);
  glutAddMenuEntry ("Maximal umbra [m]",			12);
  glutAddMenuEntry ("Local front umbra [f]",			15);
  glutAddMenuEntry ("Global front umbra [F]",			16);
  glutAddMenuEntry ("Local invisibility [b]",			11);
  glutAddMenuEntry ("Global back umbra [B]",			5);
  glutAddMenuEntry ("Label front umbra [l]",			17);
  glutAddMenuEntry ("Label back umbra [L]",			18);
  glutAddMenuEntry ("Shade local front umbra [s]",		19);
  glutAddMenuEntry ("Filled/unfilled [r]",			0);
  glutAddMenuEntry ("Animate inner sweep of umbral bitangent", 	6);
  glutAddMenuEntry ("Animate outer sweep of umbral bitangent", 	7);
  glutAddMenuEntry ("Inner umbral bitangents", 			8);
  glutAddMenuEntry ("Outer umbral bitangents (not abandoned)", 	9);
  glutAddMenuEntry ("Only for first obstacle",			10);
  glutAddMenuEntry ("Label objects",				13);
  glutAttachMenu (GLUT_RIGHT_BUTTON);

  glutMainLoop();
  return 0;
}
