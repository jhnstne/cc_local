/*
	File: quaternion.c
	Author: J.K. Johnstone
	Last Modified: Sept. 28, 1994
	Purpose: Library of quaternion functions,
		such as conversion to rotation matrix
		and quaternion multiplication.
	
*/

void quaternion_to_matrix (const Qion q, Matrix M)
{
	/* translate *unit* quaternion to rotation matrix */
	/* see Shoemake, p. 253 */
	/* Matrix is a 4x4 floating point matrix */

	REAL w,x,y,z;
	/* quaternion = (w,(x,y,z)) */
	w = q[1]/q[0];
	x = q[2]/q[0];
	y = q[3]/q[0];
	z = q[4]/q[0];

	/* last row is special */
	M[3][0]=M[3][1]=M[3][2]=0;
	M[3][3]=1;

	/* last column is special */
	M[0][3]=M[1][3]=M[2][3]=0;

	M[0][0]=1-2*y*y-2*z*z;
	M[1][0]=2*x*y - 2*w*z;
	M[2][0]=2*x*z + 2*w*y;

	M[0][1]=2*x*y + 2*w*z;
	M[1][1]=1-2*x*x-2*z*z;
	M[2][1]=2*y*z - 2*w*x;

	M[0][2]=2*x*z - 2*w*y;
	M[1][2]=2*y*z + 2*w*x;
	M[2][2]=1-2*x*x-2*y*y;
}

void draw_quaternion (Qion q)
{
	/* draw quaternion in 3d by projecting onto x_3=0 */

	draw_point(q[1]/q[0],q[2]/q[0],q[4]/q[0]);
}

void draw_4dhpoint (v4dh p)
{
	/* draw the 4d homogeneous point P in 3d by projecting onto x_2 = 0 */
	draw_point(p[1]/p[0],p[3]/p[0],p[4]/p[0]);
}

void draw_4dnurbs (const bspl_4d *bspl)
{
	/* draw a B-spline curve in 4d */

	REAL knots[MAXCTRLPTS];
	int i,last_knot;
	REAL ctlpts[MAXCTRLPTS][4];

	/* add another multiplicity to the beg and end knots for GL NURBS */
	knots[0]=bspl->knots[0];
	last_knot = bspl->L + 2*bspl->d - 2;
	for (i=0;i<=last_knot;i++)
		knots[i+1] = bspl->knots[i];
	knots[last_knot+2] = bspl->knots[last_knot];

	/* extract the x_2 component from control points
	   for visualization in 3d, and collapse into a single 2d array */
	for (i=0;i<=bspl->L+2;i++) {
		ctlpts[i][0]=bspl->x1[i];
		ctlpts[i][1]=bspl->x3[i];
		ctlpts[i][2]=bspl->x4[i];
	}

	bgncurve();
/*	nurbscurve(last_knot+3, knots, 3*sizeof(REAL), &ctlpts[0][0],4,N_V3D); */
	endcurve();
/*	draw_bspl(&bspl); */
}



void inputQion(unsigned int *n, 
	       Qion         q[],
	       FILE 	    *fp)
{
	int i;
	REAL theta;
	V3d axis, uaxis;

	/* input n quaternions */
	fscanf(fp,"%i",n);
	for (i=0;i<(*n);i++) {
		q[i][0] = 1;
		fscanf(fp,"%f",&theta); /* angle of rotation, in degrees */
/*		printf("q = (%.3f,", theta); */
		theta = deg2radians(theta);
		q[i][1] = cos(theta/2);

		fscanf(fp,"%f %f %f",axis,axis+1,axis+2); /* axis of rotation */
/*		printf("%.3f,%.3f,%.3f)",axis[0],axis[1],axis[2]); */
		unit_v3d (axis,uaxis);
		smult_v3d (uaxis,sin(theta/2),axis);
		q[i][2] = axis[0]; 
		q[i][3] = axis[1]; 
		q[i][4] = axis[2];
/*		printf(" to (%.3f,%.3f,%.3f,%.3f)\n",q[i][1], 
			q[i][2],q[i][3],q[i][4]); */
	}
}

/* void draw_oriented_wireframe (Qion q, V3d pos, int facesize[FACEMAX],
*		int n, REAL V[MAX][3])
*{
*/	/* draw the wireframe object with vertices V (n of them) */
	/* at position POS (reference vertex) and orientation Q */

	/* need to draw face by face */
	
/*	int i;
*	Matrix M;
*
*	pushmatrix();
*	translate(pos[0],pos[1],pos[2]);
*	quaternion_to_matrix(q,M);
*	multmatrix(M);
*	bgnclosedline();
*	for (i=0; i<n; i++) {
*		v3f(V[i]);
*	}
*	endclosedline();
*	popmatrix();
*}
*/

void draw_oriented_shaded_object (Qion q, V3d pos,
				  int n, int num_per_mesh[MAXMESHES],
				  REAL V[MAX][3], REAL N[MAX][3],
				  int swap[MAX])
{
	/* draw the object with tmesh vertices V and normals N (n of them) */
	/* at position POS (reference vertex) and orientation Q */
	/* the object is split into n tmeshes */
	/* num_per_mesh[i] is the number of vertices in the ith tmesh */

	int i,j,count=0;
	Matrix M;
	float norm[3];

	pushmatrix();
	translate(pos[0],pos[1],pos[2]);
	quaternion_to_matrix(q,M);
	multmatrix(M);
	for (i=0; i<n; i++) {
		bgntmesh();
		for (j=0; j<num_per_mesh[i]; j++) {
			if (swap[count])
				swaptmesh();
			norm[0] = N[count][0]; norm[1] = N[count][1]; 
			norm[2] = N[count][2]; 
 			n3f(norm); 
			v3f(V[count++]);
		}
		endtmesh();
	}
	popmatrix();
}

void generate_extruded_tmesh   (int k, 
				REAL p[MAX][3],
				REAL dist,
				REAL V[MAX][3], 
				REAL N[MAX][3],
				int swap[MAX], 
				int *num_meshes,
				int num_per_mesh[MAXMESHES])
{
	/* Given the K+1 vertices of a closed, star-shaped, planar (z=0) */
	/* polygon in P (P[0] = P[k]) */
	/* generate the tmeshes for each face of the extruded object */
	/* (NUM_MESHES of them) */
	/* generated by extruding the polygon by DIST. */
	/* Place the result in V (vertices) and N (normals) */
	/* with the number of vertices per tmesh in NUM_PER_MESH */
	/* swap[i] is 1 if a swaptmesh() should precede the output */
	/* of this vertex, 0 if not; the swap array is initially all 0 */

	REAL q[MAX][3];
	int i, count=0;
	REAL v1[3], v2[3], normal[3], unormal[3];

	*num_meshes = 3;

	/* create extruded polygon Q */
	for (i=0; i<=k; i++) {
		q[i][0] = p[i][0];
		q[i][1] = p[i][1];
		q[i][2] = dist;
	}

	/* triangulate the band between the polygons */
	for (i=0; i<k; i++) {
		minus(p[i+1], p[i], v1);
		minus(q[i],   p[i], v2);
		cross(v1,v2,normal);
		unit_v3d(normal,unormal);
		copy3d( unormal, N[count]);
		copy3d( p[i], V[count++]);
		copy3d( unormal, N[count]); /* can give p[i] and q[i] */
					       /* the same normal */
		copy3d( q[i], V[count++]);
	}
	copy3d( N[0], N[count]);
	copy3d( p[k], V[count++]);
	copy3d( N[1], N[count]);
	copy3d( q[k], V[count++]);
	num_per_mesh[0] = count;
	
	/* triangulate polygon P */
	/* assumes star-shaped polygon visible from first vertex */
	if (k>2) { 	/* k=2 is lofting */
		minus(p[2], p[0], v1);	/* be careful to preserve orientation */
		minus(p[1], p[0], v2);
		cross(v1,v2,normal);	/* same normal for entire face */
		unit_v3d(normal,unormal);
		copy3d( unormal, N[count]);
		copy3d( p[0], V[count++]);
		copy3d( unormal, N[count]);
		copy3d( p[1], V[count++]);
		for (i=2; i<k; i++) {
			swap[count] = 1; /* swaptmesh() before this vertex */
			copy3d( unormal, N[count]);
			copy3d( p[i], V[count++]);
		}
		num_per_mesh[1] = count - num_per_mesh[0];
	}

	/* triangulate extruded polygon Q */
	if (k>2) { 	
		cross(v2,v1,normal);	/* opposite normal for this face */
		unit_v3d(normal,unormal);
		copy3d( unormal, N[count]);
		copy3d( q[0], V[count++]);
		copy3d( unormal, N[count]);
		copy3d( q[1], V[count++]);
		for (i=2; i<k; i++) {
			swap[count] = 1;
			copy3d( unormal, N[count]);
			copy3d( q[i], V[count++]);
		}
		num_per_mesh[2] = count - num_per_mesh[1] - num_per_mesh[0];
	}
}

void draw_oriented_wire_cube (Qion q, V3d pos)
{
	/* draw a wireframe brick (one dimension longer) 
	   at position POS (reference vertex)
	   and orientation Q */
	/* in future: 	solid cube (using bgnmesh)
		      	cyclide (using CK)
			banana  (using Inventor or ...) */

	Matrix M;
	short v[3];

	pushmatrix();
	translate(pos[0],pos[1],pos[2]);
	quaternion_to_matrix(q,M);
	multmatrix(M);
	/* front face */
	bgnclosedline();
	v[0]=v[1]=v[2]=0;
	v3s(v);		/* (0,0,0) */
	v[0]=1;
	v3s(v);		/* (1,0,0) */
	v[2]=1;
	v3s(v);		/* (1,0,1) */
	v[0]=0;
	v3s(v);		/* (0,0,1) */
	endclosedline();

	/* back face */
	bgnclosedline();
	v[0]=v[2]=0; v[1]=2;
	v3s(v);		/* (0,2,0) */
	v[0]=1;
	v3s(v);		/* (1,2,0) */
	v[2]=1;
	v3s(v);		/* (1,2,1) */
	v[0]=0;
	v3s(v);		/* (0,2,1) */
	endclosedline();

	/* bottom face */
	bgnclosedline();
	v[0]=v[1]=v[2]=0;
	v3s(v);		/* (0,0,0) */
	v[0]=1;
	v3s(v);		/* (1,0,0) */
	v[1]=2;
	v3s(v);		/* (1,2,0) */
	v[0]=0;
	v3s(v);		/* (0,2,0) */
	endclosedline();

	/* top face */
	bgnclosedline();
	v[0]=v[1]=0; v[2]=1;
	v3s(v);		/* (0,0,1) */
	v[0]=1;
	v3s(v);		/* (1,0,1) */
	v[1]=2;
	v3s(v);		/* (1,2,1) */
	v[0]=0;
	v3s(v);		/* (0,2,1) */
	endclosedline();
	popmatrix();
}

void draw_oriented_curve (REAL display_curve[3][MAXDISPLAYPTS],
			  const int point_num,
			  const Qion q,
			  const V3d pos)
{
	/* draw a curve at orientation Q and position POS */
	Matrix M;
	short v[3];

	pushmatrix();
	translate(pos[0],pos[1],pos[2]);
	quaternion_to_matrix(q,M);
	multmatrix(M);
	draw_curve_in_3d(display_curve,point_num);
	popmatrix();
}

void draw_oriented_scaled_curve (REAL display_curve[3][MAXDISPLAYPTS],
			  const int point_num,
			  const Qion q,
			  const REAL s,
			  const V3d pos)
{
	/* draw a curve at orientation Q, scale S, and position POS */
	Matrix M;
	short v[3];

	pushmatrix();
	translate(pos[0],pos[1],pos[2]);
	scale(s,s,s);
	quaternion_to_matrix(q,M);
	multmatrix(M);
	draw_curve_in_3d(display_curve,point_num);
	popmatrix();
}
