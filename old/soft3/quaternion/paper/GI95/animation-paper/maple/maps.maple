# forward version of the mapping
Mforward := proc(V)
	temp := vector(5);
	temp[1] := V[1]^2 + V[2]^2 + V[3]^2 + V[4]^2;
	temp[2] := V[1]^2 + V[2]^2 + V[3]^2 - V[4]^2;
	temp[3] := 2*V[1]*V[4];
	temp[4] := 2*V[2]*V[4];
	temp[5] := 2*V[3]*V[4];
	eval(temp);
end;

# positive choice for inverse
Minverse1 := proc(V)
	temp := vector(4);
	w := 2*sqrt((V[1]-V[2])/2);
	temp[1] := V[3]/w;
	temp[2] := V[4]/w;
	temp[3] := V[5]/w;
	temp[4] := (V[1]-V[2])/w;
	eval(temp);
end;

# negative choice for inverse
Minverse2 := proc(V)
	temp := vector(4);
	w := -2*sqrt((V[1]-V[2])/2);
	temp[1] := V[3]/w;
	temp[2] := V[4]/w;
	temp[3] := V[5]/w;
	temp[4] := (V[1]-V[2])/w;
	eval(temp);
end;

# Cartesian distance from the origin of V a point in 4-space
dist4D := proc(V)
	evalf(sqrt(V[1]^2+V[2]^2+V[3]^2+V[4]^2));
	end;

# take a coordinate in 4d projective space and homogenize it
# to standard 4d space
homog4D := proc(V)
	temp := vector(4);
	temp[1] := V[2]/V[1];
	temp[2] := V[3]/V[1];
	temp[3] := V[4]/V[1];
	temp[4] := V[5]/V[1];
	eval(temp);
end;

# take a coordinate vector [x,y,z,w] and return [1,x,y,z,w]
project4D := proc(V)
	temp := vector(5);
	temp[1] := 1;
	temp[2] := V[1];
	temp[3] := V[2];
	temp[4] := V[3];
	temp[5] := V[4];
	eval(temp);
	end;

	
random_4sphere_point := proc()
	temp := vector(5);
	temp[2] := (rand(-500..500))();
	temp[3] := (rand(-500..500))();
	temp[4] := (rand(-500..500))();
	temp[5] := (rand(-500..500))();
	temp[1] := sqrt(temp[5]^2 + temp[2]^2 + temp[3]^2 + temp[4]^2);
	eval(temp);
	end;


testit := proc()
	points := vector(4);
	inv_points := vector(4);
	
# generate 4 random points on the unit 4-sphere

	for i from 1 to 4 do
		points[i] := random_4sphere_point();
	od;

# find the inverse maps of each of these points

	for i from 1 to 4 do
		inv_points[i] := Minverse1(points[i]);
	od;
	
# construct interpolating polynomials for the inverse points
# call these p,q,r,s

	p := interp([1,2,3,4],[inv_points[1][1],inv_points[2][1],
				inv_points[3][1],inv_points[4][1]],t);
	q := interp([1,2,3,4],[inv_points[1][2],inv_points[2][2],
				inv_points[3][2],inv_points[4][2]],t);
	r := interp([1,2,3,4],[inv_points[1][3],inv_points[2][3],
				inv_points[3][3],inv_points[4][3]],t);
	s := interp([1,2,3,4],[inv_points[1][4],inv_points[2][4],
				inv_points[3][4],inv_points[4][4]],t);

# apply the forward mapping to p,q,r,s

	q_curve := Mforward([p,q,r,s]);


# make sure that the curve interpolates the designated points
# at the designated times

	print(`t=1`);
	print(map(evalf,subs(t=1,eval(q_curve))));
	print(map(evalf,points[1]));
	print(`t=2`);
	print(map(evalf,subs(t=2,eval(q_curve))));
	print(map(evalf,points[2]));
	print(`t=3`);
	print(map(evalf,subs(t=3,eval(q_curve))));
	print(map(evalf,points[3]));
	print(`t=4`);
	print(map(evalf,subs(t=4,eval(q_curve))));
	print(map(evalf,points[4]));

# return all generated values

	eval([points,inv_points,q_curve]);
	end;


# verify that a curve lies on the unit sphere by 
# numerical testing  - plug in points

verify_sphere := proc(C)
	for i from 1 to 100 do 
		j := evalf(i/30) + 1;
		k := subs(t=j,eval(C));
		k := (map(evalf,k));
		print(dist4D(homog4D(k)));
	od;
	end;







