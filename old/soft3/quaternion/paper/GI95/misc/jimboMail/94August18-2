From jimbo@blaze.cs.jhu.edu Thu Aug 18 13:50:56 1994
Return-Path: <jimbo@blaze.cs.jhu.edu>
Received: from blaze.cs.jhu.edu by cis.uab.edu (4.1/SMI-4.1)
	id AA12739; Thu, 18 Aug 94 13:50:52 CDT
Message-Id: <9408181850.AA12739@cis.uab.edu>
Received: from mail-client (peregrine.cs.jhu.edu)
           by blaze.cs.jhu.edu; Thu, 18 Aug 94 14:50:47 EDT
From: jimbo@blaze.cs.jhu.edu (James P. Williams)
Sender: jimbo@blaze.cs.jhu.edu
Received: by mail-client (4.1) id AA19684; Thu, 18 Aug 94 14:50:46 EDT
Subject: Re: your mail
To: jj@cis.uab.edu (John Johnstone)
Date: Thu, 18 Aug 1994 14:50:46 -0400 (EDT)
In-Reply-To: <9408181525.AA10997@cis.uab.edu> from "John Johnstone" at Aug 18, 94 10:25:00 am
X-Mailer: ELM [version 2.4 PL13]
Mime-Version: 1.0
Content-Type: text/plain; charset=US-ASCII
Content-Transfer-Encoding: 7bit
Content-Length: 6143
Status: OR

> 
> I don't have Maple, but I have an Indy and an Indigo2 Extreme.
> You're right about the visualization of the curves on the
> 4-sphere, but I guess what I mean is that we need to doublecheck
> that our curves are truly on the unit sphere, via Maple I suppose,
> and get some feel for the `naturalness' of the generated curves 
> (I'm not sure how to do that right now,
> short of generating animations of a spinning object
> using the quaternions generated by the curve).
> 
> Let's concentrate on completing steps 2 and 3 to get a 
> basic version of the algorithm finished before you look
> at continuity and cusps.
> 
> We'll have to think up a natural example to test this
> on and to motivate the algorithm in the paper, but that
> can also wait a bit.
> 
> jj
> 


I have been working with a maple program that does the following:

	1 : Chooses 4 random points on the 4-sphere
	2 : applies Minverse to the points
	3 : generates 4 independent interpolating polynomials
		for the points [p,q,r,s].  points are interpolated
		at specified parameter values. in this program I
		interpolate point 1 at t=1, point 2 at t=2 etc...
		any ascending set of t's can be chosen.
	4 : applies Mforward to [p,q,r,s]
	5 : verifies interpolation of the 4 random points
	6 : tests numerically at 100 points if the generated curve 
		lies on the sphere

So far it has all checked out in practice.
You should look into acquiring a copy of Maple, I find it indispensible 
for this sort of quick prototyping and testing of numerical algorithms.

Jim

//// Maple Code and an example test session follow ////

# forward version of the mapping
Mforward := proc(V)
	temp := vector(5);
	temp[1] := V[1]^2 + V[2]^2 + V[3]^2 + V[4]^2;
	temp[2] := V[1]^2 + V[2]^2 + V[3]^2 - V[4]^2;
	temp[3] := 2*V[1]*V[4];
	temp[4] := 2*V[2]*V[4];
	temp[5] := 2*V[3]*V[4];
	eval(temp);
end;

# positive choice for inverse
Minverse1 := proc(V)
	temp := vector(4);
	w := 2*sqrt((V[1]-V[2])/2);
	temp[1] := V[3]/w;
	temp[2] := V[4]/w;
	temp[3] := V[5]/w;
	temp[4] := (V[1]-V[2])/w;
	eval(temp);
end;

# negative choice for inverse
Minverse2 := proc(V)
	temp := vector(4);
	w := -2*sqrt((V[1]-V[2])/2);
	temp[1] := V[3]/w;
	temp[2] := V[4]/w;
	temp[3] := V[5]/w;
	temp[4] := (V[1]-V[2])/w;
	eval(temp);
end;

# Cartesian distance from the origin of V a point in 4-space
dist4D := proc(V)
	evalf(sqrt(V[1]^2+V[2]^2+V[3]^2+V[4]^2));
	end;

# take a coordinate in 4d projective space and homogenize it
# to standard 4d space
homog4D := proc(V)
	temp := vector(4);
	temp[1] := V[2]/V[1];
	temp[2] := V[3]/V[1];
	temp[3] := V[4]/V[1];
	temp[4] := V[5]/V[1];
	eval(temp);
end;

# take a coordinate vector [x,y,z,w] and return [1,x,y,z,w]
project4D := proc(V)
	temp := vector(5);
	temp[1] := 1;
	temp[2] := V[1];
	temp[3] := V[2];
	temp[4] := V[3];
	temp[5] := V[4];
	eval(temp);
	end;

	
random_4sphere_point := proc()
	temp := vector(5);
	temp[2] := (rand(-500..500))();
	temp[3] := (rand(-500..500))();
	temp[4] := (rand(-500..500))();
	temp[5] := (rand(-500..500))();
	temp[1] := sqrt(temp[5]^2 + temp[2]^2 + temp[3]^2 + temp[4]^2);
	eval(temp);
	end;


testit := proc()
	points := vector(4);
	inv_points := vector(4);
	
# generate 4 random points on the unit 4-sphere

	for i from 1 to 4 do
		points[i] := random_4sphere_point();
	od;

# find the inverse maps of each of these points

	for i from 1 to 4 do
		inv_points[i] := Minverse1(points[i]);
	od;
	
# construct interpolating polynomials for the inverse points
# call these p,q,r,s

	p := interp([1,2,3,4],[inv_points[1][1],inv_points[2][1],
				inv_points[3][1],inv_points[4][1]],t);
	q := interp([1,2,3,4],[inv_points[1][2],inv_points[2][2],
				inv_points[3][2],inv_points[4][2]],t);
	r := interp([1,2,3,4],[inv_points[1][3],inv_points[2][3],
				inv_points[3][3],inv_points[4][3]],t);
	s := interp([1,2,3,4],[inv_points[1][4],inv_points[2][4],
				inv_points[3][4],inv_points[4][4]],t);

# apply the forward mapping to p,q,r,s

	q_curve := Mforward([p,q,r,s]);


# make sure that the curve interpolates the designated points
# at the designated times

	print(`t=1`);
	print(map(evalf,subs(t=1,eval(q_curve))));
	print(map(evalf,points[1]));
	print(`t=2`);
	print(map(evalf,subs(t=2,eval(q_curve))));
	print(map(evalf,points[2]));
	print(`t=3`);
	print(map(evalf,subs(t=3,eval(q_curve))));
	print(map(evalf,points[3]));
	print(`t=4`);
	print(map(evalf,subs(t=4,eval(q_curve))));
	print(map(evalf,points[4]));

# return all generated values

	eval([points,inv_points,q_curve]);
	end;


# verify that a curve lies on the unit sphere by 
# numerical testing  - plug in points

verify_sphere := proc(C)
	for i from 1 to 100 do 
		j := evalf(i/30) + 1;
		k := subs(t=j,eval(C));
		k := (map(evalf,k));
		print(dist4D(homog4D(k)));
	od;
	end;




/// Sample test session ///

> testit ();
                                      t=1

     [ 436.4435814, 17.0000002, -90.99999994, -247.9999998, -346.9999998 ]

                    [ 436.4435817, 17., -91., -248., -347. ]

                                      t=2

     [ 569.6569140, 190.0000000, -218.9999998, -487.9999997, -47.99999997 ]

                   [ 569.6569143, 190., -219., -488., -48. ]

                                      t=3

     [ 670.7376537, -322.0000001, 322.0000000, -165.0000000, -464.0000000 ]

                   [ 670.7376536, -322., 322., -165., -464. ]

                                      t=4

     [ 292.7148783, 124.9999999, -24.00000000, 109.0000000, -240.0000000 ]

                    [ 292.7148783, 125., -24., 109., -240. ]

                         [points, inv_points, q_curve]

_____________________________________________________________________________
> verify_sphere(q_curve);
                                  1.000000000

                                  1.000000000

                                  1.000000000

                                  .9999999999

                                  1.000000000

.... lots more 1.000's and .9999's ....


                                  1.000000000

                                  1.000000000

_____________________________________________________________________________
>






