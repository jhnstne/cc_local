/*
	File: fit.c
	Author: J.K. Johnstone
	Last Modified: Oct. 13, 1994
	Purpose: Package of fitting routines: curves to points,
		surfaces to points, surfaces to curves.
		Only cubic Bezier and B-spline fitting is presently
		implemented.  In future we hope to have a `fit' command	
		with options including:
			curve/surface
			degree (cubic, ...)
			param type (uniform, chord-length, ...)
			closed/open	
*/

void fitQuadraticBspl_1d (const int n, const double p[], bspl_1d *bspl)
{
	/* fit quadratic B-spline through n doubles */
	/* i.e., create B-spline polygon of 
}

void fitCubicBspl_3d (const int n, const V3d p[],  bspl_3d *bspl)
{
	/* fit cubic B-spline through n 3d points in p */
	/* i.e., create B-spline polygon of an interpolating C^2 cubic spline curve */

	int i;
	double data_x1[MAXPTS+2],data_x2[MAXPTS+2],data_x3[MAXPTS+2];
	double knot[MAXPTS];
	double alpha[MAXPTS],beta[MAXPTS],gamma[MAXPTS];
	double up[MAXPTS],low[MAXPTS];

	extract_data_3d (n,p,data_x1,data_x2,data_x3);
	/* Note: knot sequence generated by centripetal_knots does not have
		 multiplicity d knots at beg and end: they are just counted
		 once */
	centripetal_knots_3d(data_x1,data_x2,data_x3,n-1,knot);
	set_up_system(knot,n-1,alpha,beta,gamma);
	l_u_system(alpha,beta,gamma,n-1,up,low);
	bessel_ends(data_x1,knot,n-1);
	bessel_ends(data_x2,knot,n-1);
	bessel_ends(data_x3,knot,n-1);
	solve_system(up,low,gamma,n-1,data_x1,bspl->x1);
	solve_system(up,low,gamma,n-1,data_x2,bspl->x2);
	solve_system(up,low,gamma,n-1,data_x3,bspl->x3);

	bspl->d = 3;
	bspl->L = n-1;
	bspl->knots[0]= bspl->knots[1] = knot[0]; /* mult 3 knot at beg */
	for (i=0;i<=bspl->L;i++) {
		bspl->knots[i+2] = knot[i];
	}
	bspl->knots[bspl->L+3] = bspl->knots[bspl->L+4] = knot[bspl->L];
						  /* mult 3 knot at end */
}

void fitCubicBspl_4dh(const int n, const v4dh p[], bspl_4d *bspl)
{
	/* fit cubic B-spline through n 4d homogeneous points in p */
	/* i.e., create B-spline polygon of an interpolating C^2 cubic spline curve */

	int i;
	double data_x1[MAXPTS+2],data_x2[MAXPTS+2],data_x3[MAXPTS+2],
	       data_x4[MAXPTS+2];
	double knot[MAXPTS];
	double alpha[MAXPTS],beta[MAXPTS],gamma[MAXPTS];
	double up[MAXPTS],low[MAXPTS];

	extract_data_4dh (n,p,data_x1,data_x2,data_x3,data_x4);
	/* Note: knot sequence generated by centripetal_knots does not have
		 multiplicity d knots at beg and end: they are just counted
		 once */
	centripetal_knots_4d(data_x1,data_x2,data_x3,data_x4,n-1,knot);
	set_up_system(knot,n-1,alpha,beta,gamma);
	l_u_system(alpha,beta,gamma,n-1,up,low);
	bessel_ends(data_x1,knot,n-1);
	bessel_ends(data_x2,knot,n-1);
	bessel_ends(data_x3,knot,n-1);
	bessel_ends(data_x4,knot,n-1);
	solve_system(up,low,gamma,n-1,data_x1,bspl->x1);
	solve_system(up,low,gamma,n-1,data_x2,bspl->x2);
	solve_system(up,low,gamma,n-1,data_x3,bspl->x3);
	solve_system(up,low,gamma,n-1,data_x4,bspl->x4);

	bspl->d = 3;
	bspl->L = n-1;
	bspl->knots[0]= bspl->knots[1] = knot[0]; /* mult 3 knot at beg */
	for (i=0;i<=bspl->L;i++) {
		bspl->knots[i+2] = knot[i];
	}
	bspl->knots[bspl->L+3] = bspl->knots[bspl->L+4] = knot[bspl->L];
						  /* mult 3 knot at end */
}

void extract_data_3d  (const int n, const V3d p[], 
		       double data_x1[], double data_x2[], double data_x3[])
{
	/* copy data from n points in P into x1 thru x3 coordinates,
	   leaving 1st and nth positions empty for insertion of Bessel 
	   end conditions */

	int i;

	data_x1[0] = p[0][0];
	data_x2[0] = p[0][1];
	data_x3[0] = p[0][2];

	for (i=1;i<n-1;i++) {
		data_x1[i+1] = p[i][0];
		data_x2[i+1] = p[i][1];
		data_x3[i+1] = p[i][2];
	}

	data_x1[n+1] = p[n-1][0];
	data_x2[n+1] = p[n-1][1];
	data_x3[n+1] = p[n-1][2];
}

void extract_data_4dh (const int n, const v4dh p[], 
		       double data_x1[], double data_x2[],
		       double data_x3[], double data_x4[])
{
	/* copy data from n points in P into x1 thru x4 coordinates,
	   leaving 1st and nth positions empty for insertion of Bessel 
	   end conditions */

	int i;

	data_x1[0] = p[0][1]/p[0][0];
	data_x2[0] = p[0][2]/p[0][0];
	data_x3[0] = p[0][3]/p[0][0];
	data_x4[0] = p[0][4]/p[0][0];

	for (i=1;i<n-1;i++) {
		data_x1[i+1] = p[i][1]/p[i][0];
		data_x2[i+1] = p[i][2]/p[i][0];
		data_x3[i+1] = p[i][3]/p[i][0];
		data_x4[i+1] = p[i][4]/p[i][0];
	}

	data_x1[n+1] = p[n-1][1]/p[n-1][0];
	data_x2[n+1] = p[n-1][2]/p[n-1][0];
	data_x3[n+1] = p[n-1][3]/p[n-1][0];
	data_x4[n+1] = p[n-1][4]/p[n-1][0];
}

void centripetal_knots_2d(double data_x[], double data_y[], int l, double knot[])
/*	Finds a centripetal parametrization for a given set
	of 2D data points. 
Input:	data_x, data_y:	input points, numbered from 0 to l+2. 
	l:		number of intervals.
Output:	knot:		knot sequence. Note: not (knot[l]=1.0)!
Note:	data_x[1], data_x[l+1] are not used! Same for data_y.
*/
	/* scavenged from `parameters', Farin, 3rd ed. diskette */
{
	int i,l1,l2;      /* In the following, special care must be taken */
	double delta;       /* at the ends because of the data structure */
	                   /* used. See note above.                     */
	l1= l-1; l2 = l+2;
	knot[0] = 0.0;     /* initialize -- arbitrary */

	delta=sqrt((data_x[2]-data_x[0])*(data_x[2]-data_x[0])
		         +(data_y[2]-data_y[0])*(data_y[2]-data_y[0]));
	knot[1]= sqrt(delta);                /* leave out this sqrt
		                                if you want chord length.*/

	for(i=2; i<l; i++)
	{
	        delta=sqrt((data_x[i+1]-data_x[i])*(data_x[i+1]-data_x[i])
		         +(data_y[i+1]-data_y[i])*(data_y[i+1]-data_y[i]));

		knot[i]=knot[i-1]+sqrt(delta);/*leave out this sqrt
		                                if you want chord length.*/
	}

	delta=sqrt((data_x[l2]-data_x[l])*(data_x[l2]-data_x[l])
		         +(data_y[l2]-data_y[l])*(data_y[l2]-data_y[l]));
	knot[l]= knot[l-1]+sqrt(delta);      /* leave out this sqrt
		                                if you want chord length.*/
}

void centripetal_knots_3d(double data_x1[], double data_x2[], double data_x3[], 
			  int l, double knot[])
/*	Finds a centripetal parametrization for a given set
	of 3D data points. 
Input:	data_x1,data_x2,data_x3: input points, numbered from 0 to l+2. 
	l:		number of intervals.
Output:	knot:		knot sequence. Note: not (knot[l]=1.0)!
		numbered from 0 to l
Note:	data_x1[1], data_x1[l+1] are not used! Same for other data_xi.
*/
	/* scavenged from `parameters', Farin, 3rd ed. diskette */
{
	int i;      /* In the following, special care must be taken */
	double delta;       /* at the ends because of the data structure */
	                   /* used. See note above.                     */
	knot[0] = 0.0;     /* initialize -- arbitrary */

	delta=sqrt(pow(data_x1[2]-data_x1[0], 2)
		 + pow(data_x2[2]-data_x2[0], 2)
		 + pow(data_x3[2]-data_x3[0], 2)); /* || x[2] - x[0] || */
	knot[1]= sqrt(delta);                /* leave out this sqrt
		                                if you want chord length.*/
	for(i=2; i<l; i++)
	{
	        delta=sqrt(pow (data_x1[i+1]-data_x1[i], 2)
		         + pow (data_x2[i+1]-data_x2[i], 2)
		         + pow (data_x3[i+1]-data_x3[i], 2));
		knot[i]=knot[i-1]+sqrt(delta);/*leave out this sqrt
		                                if you want chord length.*/
	}

	delta=sqrt(pow(data_x1[l+2]-data_x1[l], 2)
		 + pow(data_x2[l+2]-data_x2[l], 2)
		 + pow(data_x3[l+2]-data_x3[l], 2));
	knot[l]= knot[l-1]+sqrt(delta);      /* leave out this sqrt
		                                if you want chord length.*/
}

void centripetal_knots_4d(double data_x1[], double data_x2[], 
			  double data_x3[], double data_x4[], 
			  int l, double knot[])
/*	Finds a centripetal parametrization for a given set
	of 4D data points. 
Input:	data_x1,data_x2,data_x3,data_x4: input points, numbered from 0 to l+2. 
	l:		number of intervals.
Output:	knot:		knot sequence. Note: not (knot[l]=1.0)!
		numbered from 0 to l
Note:	data_x1[1], data_x1[l+1] are not used! Same for other data_xi.
*/
	/* scavenged from `parameters', Farin, 3rd ed. diskette */
{
	int i;      /* In the following, special care must be taken */
	double delta;       /* at the ends because of the data structure */
	                   /* used. See note above.                     */
	knot[0] = 0.0;     /* initialize -- arbitrary */

	delta=sqrt(pow(data_x1[2]-data_x1[0], 2)
		 + pow(data_x2[2]-data_x2[0], 2)
		 + pow(data_x3[2]-data_x3[0], 2)
		 + pow(data_x4[2]-data_x4[0], 2)); /* || x[2] - x[0] || */
	knot[1]= sqrt(delta);                /* leave out this sqrt
		                                if you want chord length.*/
	for(i=2; i<l; i++)
	{
	        delta=sqrt(pow (data_x1[i+1]-data_x1[i], 2)
		         + pow (data_x2[i+1]-data_x2[i], 2)
		         + pow (data_x3[i+1]-data_x3[i], 2)
		         + pow (data_x4[i+1]-data_x4[i], 2));
		knot[i]=knot[i-1]+sqrt(delta);/*leave out this sqrt
		                                if you want chord length.*/
	}

	delta=sqrt(pow(data_x1[l+2]-data_x1[l], 2)
		 + pow(data_x2[l+2]-data_x2[l], 2)
		 + pow(data_x3[l+2]-data_x3[l], 2)
		 + pow(data_x4[l+2]-data_x4[l], 2));
	knot[l]= knot[l-1]+sqrt(delta);      /* leave out this sqrt
		                                if you want chord length.*/
}

void set_up_system(double knot[], int l, 
		   double alpha[], double beta[], double gamma[])
/*	given the knot sequence, the linear system 
	for clamped end condition B-spline interpolation
	is set up.
input:	knot:	knot sequence
	points:	points to be interpolated
	l:	number of intervals
output:	alpha,beta,gamma: 1-D arrays that constitute
		the elements of the interpolation matrix.

	Note: no data points needed so far! 
*/
	/* scavenged from Farin Curves and Surfaces for CAGD, 3rd ed., diskette */
{
	int i,l1;
	double delta_im2,delta_im1, delta_i, delta_ip1,sum;
	l1=l-1;

	/* some special cases: */
	if(l==1)
	{alpha[0]=0.0; alpha[1]=0.0; beta[0]=1.0; beta[1]=1.0;
	 gamma[0]=0.0; gamma[1]=0.0; return;}

	if(l==2)
	{
		beta[0]=1.0;
		delta_im1=(knot[1]-knot[0]);
		delta_i  =(knot[2]-knot[1]);
		delta_ip1=(knot[3]-knot[2]);
		sum = delta_im1+delta_i;

		alpha[1]=delta_i*delta_i/sum;
		beta[1] =(delta_i*delta_im1)/sum
                + delta_im1*delta_i/ sum;
		gamma[1]=delta_im1*delta_im1/sum;

		alpha[1]=alpha[1]/sum;
		beta[1] =beta[1]/sum;
		gamma[1]=gamma[1]/sum;

		beta[2]=1.0;
		alpha[2]=0.0;
		gamma[2]=0.0;
		return;
	}

	/* the rest does the cases l>2.  */

	delta_im1=(knot[1]-knot[0]);
	delta_i  =(knot[2]-knot[1]);
	delta_ip1=(knot[3]-knot[2]);
	sum = delta_im1+delta_i;

	beta[0]=1.0; gamma[0]=0.0;

	alpha[1]=delta_i*delta_i/sum;
	beta[1] =(delta_i*delta_im1)/sum
                + delta_im1*(delta_i+delta_ip1)
		/ (sum+delta_ip1);
	gamma[1]=delta_im1*delta_im1/(sum+delta_ip1);

	alpha[1]=alpha[1]/sum;
	beta[1] =beta[1]/sum;
	gamma[1]=gamma[1]/sum;

	/*Now for the main loop:   */
	for(i=2; i<l1; i++)
	{
		/* compute delta_i_minus_2,...  */
		delta_im2=(knot[i-1]-knot[i-2]);
		delta_im1=(knot[i]  -knot[i-1]);
		delta_i  =(knot[i+1]-knot[i]);
		delta_ip1=(knot[i+2]-knot[i+1]);
	
		sum = delta_im1+delta_i;

		alpha[i]=delta_i*delta_i/(delta_im2 +sum);
		beta[i] =delta_i*(delta_im2+delta_im1) 
			/(delta_im2 + sum)
			+
			 delta_im1*(delta_i+delta_ip1)
			/(sum + delta_ip1);
		gamma[i]=delta_im1*delta_im1
			/(sum + delta_ip1);
		
		alpha[i]=alpha[i]/sum;
		beta[i] =beta[i]/sum;
		gamma[i]=gamma[i]/sum;
	}

	/*  special care at the end:  */
	delta_im2=knot[l-2]-knot[l-3];
	delta_im1=knot[l1]-knot[l-2];
	delta_i  =knot[l]-knot[l1];
	sum=delta_im1+delta_i;

	alpha[l1]=delta_i*delta_i/(delta_im2+sum);
	beta[l1] =delta_i*(delta_im2+delta_im1)/(delta_im2  + sum)
                 +
		  delta_im1*delta_i / sum;
	gamma[l1]=delta_im1*delta_im1/sum;

	alpha[l1]=alpha[l1]/sum;
	beta[l1] =beta[l1]/sum;
	gamma[l1]=gamma[l1]/sum;

	alpha[l]=0.0; beta[l]=1.0; gamma[l]=0.0;
}

void l_u_system(double alpha[], double beta[], double gamma[],
		int l, double up[], double low[])
/*	perform LU decomposition of tridiagonal system with
	lower diagonal alpha, diagonal beta, upper diagonal gamma.

input:	alpha,beta,gamma: the coefficient matrix entries
	l:	matrix size [0,l]x[0,l]
	low:	L-matrix entries
	up:	U-matrix entries
*/
	/* scavenged from Farin, 3rd edition diskette */
{
	int i;

	up[0]=beta[0];
	for(i=1; i<=l; i++)
	{
		low[i]=alpha[i]/up[i-1];
		up[i] =beta[i]-low[i]*gamma[i-1];
	}
}

void bessel_ends(double data[], double knot[], int l)
/*	Computes B-spline points data[1] and data[l+1]
	according to Bessel end condition.

input:	data:	sequence of data coordinates data[0] to data[l+2].
		Note that data[1] and data[l+1] are expected to
		be empty, as they will be filled by this routine.
	knot:	knot sequence
	l:	number of intervals
 
output:	data:	completed, as above.
*/
	/* scavenged from Farin, 3rd edition diskette */
{
	double alpha, beta; int i;
	
	if (l==1)
	{/*  This is not really Bessel, but then what do you do
	     when you have only one interval? -- make it linear!
	 */
		data[1]= (2.0*data[0] + data[3])/3.0;
		data[2]= (2.0*data[3] + data[0])/3.0;
	}
	else if (l==2)
	{
		/* beginning:    */
		alpha= (knot[2]-knot[1])/(knot[2]-knot[0]);
		beta = 1.0 - alpha;

		data[1]=(data[2]-alpha*alpha*data[0]-beta*beta*data[4])
		/(2.0*alpha*beta);
		data[1]=2.0*(alpha*data[0]+beta*data[1])/3.0 + data[0]/3.0;

		/* end:  */
		alpha= (knot[2]-knot[1])/(knot[2]-knot[0]);
		beta = 1.0 - alpha;

		data[3]=(data[2]-alpha*alpha*data[0]-beta*beta*data[4])
		/(2.0*alpha*beta);

		data[3]=2.0*(alpha*data[3]+beta*data[4])/3.0+data[4]/3.0;
	}
	else
	{
		/* beginning:    */
		alpha= (knot[2]-knot[1])/(knot[2]-knot[0]);
		beta = 1.0 - alpha;

		data[1]=(data[2]-alpha*alpha*data[0]-beta*beta*data[3])
		/(2.0*alpha*beta);
		data[1]=2.0*(alpha*data[0]+beta*data[1])/3.0 + data[0]/3.0;

		/* end:  */
		alpha= (knot[l]-knot[l-1])/(knot[l]-knot[l-2]);
		beta = 1.0 - alpha;

		data[l+1]=(data[l]-alpha*alpha*data[l-1]-beta*beta*data[l+2])
		/(2.0*alpha*beta);

		data[l+1]=2.0*(alpha*data[l+1]+beta*data[l+2])/3.0+data[l+2]/3.0;
	}
}

void solve_system(double up[], double low[], double gamma[],
		  int l, double rhs[], double d[])
/*	solve  tridiagonal linear system
	of size (l+1)(l+1) whose LU decompostion has entries up and low,
	and whose right hand side is rhs, and whose original matrix
	had upper diagonal gamma. Solution is d[0],...,d[l+2];
Input: up,low,gamma:  as above.
       l:             size of system: l+1 eqs in l+1 unknowns.
       rhs:           right hand side, i.e, data points with end
                      `tangent Bezier points' in rhs[1] and rhs[l+1].
Output:d:             solution vector.

Note:	Both rhs and d are from 0 to l+2.
*/
	/* scavenged from Farin, 3rd edition diskette */
{
	int i;
	double aux[100];

	d[0] = rhs[0];
	d[1] = rhs[1];

	/* forward substitution:  */
	aux[0]=rhs[1];
	for(i=1; i<=l; i++) aux[i]=rhs[i+1]-low[i]*aux[i-1];
	
	/* backward substitution:  */
	d[l+1]=aux[l]/up[l];
	for(i=l-1; i>0; i--) d[i+1]=(aux[i]-gamma[i]*d[i+2])/up[i];
	d[l+2]=rhs[l+2];
}


