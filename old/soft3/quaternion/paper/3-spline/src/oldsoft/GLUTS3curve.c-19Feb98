/*
        File: GLUTS3curve.c
        Author: J.K. Johnstone
        Created: circa 23 August 1996
	Last modified: 5 August 1997
        Purpose: Input: n points on the sphere S^3
		 Output: rational interpolating Bezier spline
	Reference: John K. Johnstone and James T. Williams (1996)
		   `Rational interpolating curves on the 3-sphere'
		   UAB Technical report, October 1996.
	Basically: Perturb input away from pole, map points to image space,
			interpolate and map curve back.
	History: 4/14/97: Perturbed input points to avoid pole.
		 4/15/97: Used rotation matrix to rotate, rather than incorrect
				quaternion multiplication.
		 4/16/97: Added pan.
		 4/16/97: Different perturbation routine using minimum eigenvector
			  of covariance matrix.
		 4/18/97: Distinguish between visualization and `true' computation.
		 4/21/97: Enforce minimal sampling rate of quaternions,
			to avoid no perturbation with (0,0,1), (0,1,0), (1,0,0)
			input.  This is overkill, since only this set exhibits
			the bad behaviour of yielding no perturbation,
			even if larger sampling distances are chosen;
			but it is a reasonable assumption and a sufficient
			condition to avoid trouble.
			Moreover, it avoids the problem of choosing the
			wrong quaternion from the quaternion pair:
			this will create antipodally opposite quaternion,
			which will be flagged by the sampling criterion.
		 4/23/97: Changed imagept from V5r to V4r.
			Added random input option, for better testing.
		 4/24/97: Fit prescribed tangent at beginning of S3 curve.
		 8/5/97: Added spherical projection version of image curve generation.
		 8/6/97: Spit random input out to file (random.dat) for future use.
			 Added quality analysis (net tangential acceleration).
		 8/12/97: Added hyperplane display.

	Test for cusps?
	Compute knot sequence based on spherical chord-length parameterization?
	Split points into smaller sets, connected with C^2 continuity,
		if large point set forces some point too close to pole?
		(or two points on opposite sides of pole?)
	Compute amount of tangential acceleration of our curves.
*/

#include <GL/glut.h>
#include <math.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <REAL.h>
#include <Misc.h>
#include <Vec.h>
#include <Vec4d.h>
#include <Matrix.h>
#include <Matrix4d.h>
#include <Bez4d.h>
#include <Fit4d.h>
#include <Fit3sphere.h>
#include <Quality.h>

#define PI 		 3.141593
#define MAXANGLEDIFF 	 PI/2 	/* formerly PI/3 */
#define PTSPERBEZSEGMENT 40	/* # of points to draw on each Bezier segment */
				/* previously 20 */
#define NQUALITYPROBES 	 50	/* # of points to discretely sample in TangAccel_Spherical */

static char *RoutineName;
static void usage()
{
  printf("Usage is %s\n", RoutineName);
  printf("\t[-r]   - (r)andom input (between 3 and 100 points)\n");
  printf("\t[-n #] - (n)umber of random points\n");
  printf("\t[-i]   - quaternion (i)nput as angle-axis\n");
  printf("\t[-v]   - (v)isualize\n");
  printf("\t < InputData\n");
}

static GLfloat   transx, transy, transz, rotx, roty, rotz, zoom;
static GLfloat   initrotx, initroty, initrotz;
static GLboolean rotate=0;	/* start rotating? */
static int 	 panLeft=0;  		/* control panning for 3d effect */
static int 	 panRight=1;
static GLboolean leftMouseDown=0;
static GLboolean middleMouseDown=0;
static GLboolean rightMouseDown=0;
static int	 firstx=1;	/* first MOUSEX reading? */
static int 	 firsty=1;
static int	 oldx,oldy;	/* previous value of MOUSEX and MOUSEY */
static int	 DRAWHYPERPLANE=0;	/* draw hyperplane of stereog proj? */
static int	 DRAWPOLE=0;		/* draw pole of M (to be avoided)? */
static int	 DRAWDATAPTS=0;
static int	 DRAWPERTURBPTS=1;
static int	 DRAWSOURCEPERTURBPT=0;
static int	 DRAWIMAGEPTS=0;
static int	 DRAWIMAGEPTS2=0;
static int	 DRAWIMAGECURVE=0;
static int	 DRAWIMAGECURVE2=0;
static int	 DRAWS3CURVE=0;
static int	 DRAWPERTURBS3CURVE=1;
static int	 DRAWPERTURBS3CURVE2=1;
static int	 DRAWS3CTLPOLY=0;
static int	 DRAWPERTURBS3CTLPOLY=0;
static int	 DRAWIMAGECTLPOLY=0;
static int	 DRAWIMAGELINES=0;	/* draw lines from pole to stereog image? */
static int 	 DRAWFIGURE=0;	/* draw figure of stereog proj map (for paper)? */
static GLboolean PAN=0;	 	/* rotate object back and forth for 3d effect? */
static int 	 DEBUG = 0;	/* print debug statements? */
static GLboolean INPUTANGLEAXIS=0;
static GLboolean VISUALIZE=0;	/* draw S3 curve on quaternion sphere? */
static GLboolean RANDOMINPUT=0;	/* generate input randomly? */
static GLboolean NPTKNOWN=0;	/* # of random points given on command line? */

int       n;			/* # of input points */
V4r      *pt;			/* input points */
V4r       qNew;			/* point to be mapped to pole for perturbation */
V4r 	 *perturbpt;		/* perturbed input points */
V4r      *imagept;		/* images of input points under M^{-1} */
V4r      *imagept2;		/* images of input points under spherical proj */
RatBez4d  perturbS3curve;	/* sextic curve on unit 3-sphere S3 (M map) */
RatBez4d  perturbS3curve2;	/* sextic curve on unit 3-sphere S3 (stereo proj map) */
RatBez4d  S3curve;		/* sextic curve on unit 3-sphere S3 */
Bez4d     imageBez;		/* cubic image curve under M^{-1} */
Bez4d     imageBez2;		/* cubic image curve under spherical proj */
V4r      *perturbS3curveDisplay;
V4r      *perturbS3curveDisplay2;
V4r      *S3curveDisplay;
V4r      *imageCurveDisplay;
V4r      *imageCurveDisplay2;

void gfxinit(void)
{
/*GLfloat mat_ambient[]    = {0.8, 0.1, 0.1, 1.0}; */
  GLfloat mat_ambient[]    = {0.1745, 0.01175, 0.01175}; 
  GLfloat mat_specular[]   = {0.1, 0.1, 0.1, 1.0};
/*GLfloat mat_diffuse[]    = {0.8, 0.5, 1.0, 1.0}; */  		/* purple */
  GLfloat mat_diffuse[]    = {0.61424, 0.04136, 0.04136, 1.0}; 	/* red */
  GLfloat mat_emission[]   = {0.1, 0.1, 0.1, 1.0};
/*GLfloat high_shininess[] = { 30.0 }; */
  GLfloat high_shininess[] = { 0.6 * 128.0 };
  GLfloat light0_position[] = {-2.0, 0.0, 0.0, 0.0};		/* from left */
  GLfloat light1_position[] = {2.0, 0.0, 0.0, 0.0};		/* right */
  GLfloat light2_position[] = {0.0, -2.0, 0.0, 0.0};		/* back */
  GLfloat light3_position[] = {0.0, 2.0, 0.0, 0.0};		/* front */
  GLfloat light4_position[] = {0.0, 0.0, 2.0, 0.0};		/* top */
  GLfloat light5_position[] = {0.0, 0.0, -2.0, 0.0};		/* bottom */
  GLfloat light_ambient[]   = {0.2, 0.2, 0.2, 1.0};
  GLfloat whitelight[]      = {1.0, 1.0, 1.0, 1.0};

  glClearColor (1.0, 1.0, 1.0, 1.0);
/*glEnable(GL_DEPTH_TEST); */
  glShadeModel (GL_FLAT);

  glMaterialfv (GL_FRONT, GL_AMBIENT,   mat_ambient);
  glMaterialfv (GL_FRONT, GL_DIFFUSE,   mat_diffuse);
  glMaterialfv (GL_FRONT, GL_SPECULAR,  mat_specular);
  glMaterialfv (GL_FRONT, GL_SHININESS, high_shininess);
  glMaterialfv (GL_FRONT, GL_EMISSION,  mat_emission); 
/*glColorMaterial (GL_FRONT, GL_DIFFUSE); */        /* set material using color */ 
/*glEnable (GL_COLOR_MATERIAL); */

/*glLightModeli (GL_LIGHT_MODEL_LOCAL_VIEWER, GL_TRUE);  */ /* more expensive */
  glLightfv (GL_LIGHT0, GL_POSITION, light0_position);  
  glLightfv (GL_LIGHT1, GL_POSITION, light1_position); 
  glLightfv (GL_LIGHT2, GL_POSITION, light2_position); 
  glLightfv (GL_LIGHT3, GL_POSITION, light3_position); 
  glLightfv (GL_LIGHT4, GL_POSITION, light4_position); 
  glLightfv (GL_LIGHT5, GL_POSITION, light5_position);
  glLightfv (GL_LIGHT0, GL_DIFFUSE, whitelight);
  glLightfv (GL_LIGHT1, GL_DIFFUSE, whitelight);
  glLightfv (GL_LIGHT2, GL_DIFFUSE, whitelight);
  glLightfv (GL_LIGHT3, GL_DIFFUSE, whitelight);
  glLightfv (GL_LIGHT4, GL_DIFFUSE, whitelight);
  glLightfv (GL_LIGHT5, GL_DIFFUSE, whitelight);

/*glEnable (GL_LIGHTING); */
  glEnable (GL_LIGHT0);
  glEnable (GL_LIGHT1);
  glEnable (GL_LIGHT2);
  glEnable (GL_LIGHT3);
  glEnable (GL_LIGHT4);
  glEnable (GL_LIGHT5);

  glEnable (GL_BLEND);
  glBlendFunc (GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);
  glEnable (GL_POINT_SMOOTH); 
  glHint (GL_POINT_SMOOTH_HINT, GL_FASTEST);
  glEnable (GL_LINE_SMOOTH);
  glHint (GL_LINE_SMOOTH_HINT, GL_FASTEST);
  glPointSize (10.0);
  glLineStipple (1, 0xAAAA);

  transx = 0.0;  transy = 0.0;  transz = 0.0;
  rotx = initrotx = 0.0;	/* previously 90 */
  roty = initroty = 0.0;
  rotz = initrotz = 0.0;	/* 73 for #2 visible control polygon */
				/* previously 40 */
  zoom = 1.5;
}

/******************************************************************************/
/******************************************************************************/

void reshape(GLsizei w, GLsizei h)
{
  glViewport(0, 0, w, h);
  glMatrixMode(GL_PROJECTION);
  glLoadIdentity();
  glOrtho(-2.0*(GLfloat)w/(GLfloat)h, 2.0*(GLfloat)w/(GLfloat)h, -2.0, 2.0, -6.0, 6.0);
  glMatrixMode(GL_MODELVIEW);
  glLoadIdentity();
}

/******************************************************************************/
/******************************************************************************/

void Rotate (void)
{
  rotz += 2.0; 
  if (rotz > 360.0) 
    rotz -= 360.0;
  glutPostRedisplay();
}

/******************************************************************************/
/******************************************************************************/

void Pan (void)
{
  if (panLeft)
   {
    rotz += 0.1;
    if (rotz > 360.0)
      rotz -= 360.0;
    panLeft++;
    if (panLeft==200)
     {
       panLeft=0;
       panRight=1;
     }
   }
  else if (panRight)
   {
    rotz -= 0.1;
    if (rotz < 0.0)
      rotz += 360.0;
    panRight++;
    if (panRight==200)
     {
      panRight=0;
      panLeft=1;
     }
   }
  glutPostRedisplay();
}

/******************************************************************************/
/******************************************************************************/

void visibility (int status)
{
  if (status != GLUT_VISIBLE) {
    if (rotate || PAN)
      glutIdleFunc (NULL);
  }
  else if (rotate)
    glutIdleFunc (Rotate);
  else if (PAN)
    glutIdleFunc (Pan);
}

/******************************************************************************/
/******************************************************************************/

void keyboard (unsigned char key, int x, int y)
{
  if (key == 27)	/* ESCAPE */
    exit(1);
  else if (key == 114)  /* r: toggle rotation */
    if (rotate) {
      rotate=0;
      glutIdleFunc (NULL);
    }
    else {
      rotate=1;
      glutIdleFunc (Rotate);
    }
  else if (key == 112) /* p: toggle pan */
    if (PAN) {
      PAN = 0;
      glutIdleFunc (NULL);
    }
    else {
      PAN = 1;
      glutIdleFunc (Pan);
    }
}

/******************************************************************************/
/******************************************************************************/

void mouse (int button, int state, int x, int y)
{
  switch (button) {
  case GLUT_LEFT_BUTTON:
	switch (state) {
	case GLUT_DOWN: 
 	  leftMouseDown = firstx = firsty = 1;
	  glutSetCursor (GLUT_CURSOR_UP_DOWN);
	  break;
	case GLUT_UP: 
	  leftMouseDown = 0;
	  glutSetCursor (GLUT_CURSOR_INHERIT);
	  break;
	default: break;
	}
	break;
  case GLUT_MIDDLE_BUTTON:
	switch (state) {
	case GLUT_DOWN:
	  middleMouseDown = firstx = firsty = 1; 
	  glutSetCursor (GLUT_CURSOR_CYCLE);
	  break;
	case GLUT_UP: 		
	  middleMouseDown = 0; 
	  glutSetCursor (GLUT_CURSOR_INHERIT);
	  break;
	default: break;
	}
	break;
  default:
	break;
  }
}

/******************************************************************************/
/******************************************************************************/

void motion (int x, int y)
{
  if (leftMouseDown && !middleMouseDown)	   
   {
    if (firstx)  firstx=0; else zoom -= (float).02*(x-oldx);
   }
  else if (leftMouseDown && middleMouseDown)
   {
    if (firstx)  firstx=0; else transx += .01*(x-oldx); /* TRANSLATION: X */
    if (firsty)  firsty=0; else transy += .01*(y-oldy); /* TRANSLATION: Y */
   }
  else if (middleMouseDown) 
   {
    if (firstx)  firstx=0;
    else { roty += .5*(x-oldx); if (roty > 360.0) roty -= 360.0; } /* ORI: Y */

    if (firsty)  firsty=0;
    else { rotx += .5*(y-oldy); if (rotx > 360.0) rotx -= 360.0; } /* ORI: X */
   }
  oldx = x;  
  oldy = y;
  glutPostRedisplay();
}

/******************************************************************************/
/******************************************************************************/

void menu (int value)
{
  switch (value) {
  case 1:	DRAWDATAPTS = !DRAWDATAPTS;    			break;
  case 2:	DRAWSOURCEPERTURBPT = !DRAWSOURCEPERTURBPT;  	break;
  case 3: 	DRAWPERTURBPTS = !DRAWPERTURBPTS; 		break;
  case 4:	DRAWIMAGEPTS = !DRAWIMAGEPTS;  			break;
  case 5:	DRAWIMAGECURVE = !DRAWIMAGECURVE;		break;
  case 6:	DRAWIMAGECTLPOLY = !DRAWIMAGECTLPOLY;		break;
  case 7:	DRAWPERTURBS3CURVE = !DRAWPERTURBS3CURVE;    	break;
  case 8:	DRAWPERTURBS3CTLPOLY = !DRAWPERTURBS3CTLPOLY;	break;
  case 9:	DRAWS3CURVE = !DRAWS3CURVE;    			break;
  case 10:	DRAWS3CTLPOLY = !DRAWS3CTLPOLY;			break;
  case 11:	DRAWIMAGEPTS2 = !DRAWIMAGEPTS2;			break;
  case 12:	DRAWIMAGECURVE2 = !DRAWIMAGECURVE2;		break;
  case 13:	DRAWPERTURBS3CURVE2 = !DRAWPERTURBS3CURVE2;    	break;
  case 14:	DRAWHYPERPLANE = !DRAWHYPERPLANE;		break;
  case 15:	DRAWIMAGELINES = !DRAWIMAGELINES;		break;
  case 16:	DRAWPOLE = !DRAWPOLE;				break;
  case 17:	DRAWFIGURE = !DRAWFIGURE;			break;
  default: 	break;
  }
  glutPostRedisplay();
}

/******************************************************************************/
/******************************************************************************/

void display (void)
{
  int i,j;

  glClear (GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
  glPushMatrix();
  glTranslatef (transx, transy, transz);
  glRotatef (rotx, 1.0, 0.0, 0.0);
  glRotatef (roty, 0.0, 1.0, 0.0);
  glRotatef (rotz, 0.0, 0.0, 1.0);
  glScalef  (zoom, zoom, zoom);

  glColor3f (0.5, 0.5, 0.5);	/* grey sphere */
  glLineWidth (1.0);
  glutWireSphere (1.0, 20, 20);

  if (DRAWPOLE)
   {
    glColor3f (1,0,0);		/* red pole */
    glBegin (GL_POINTS);
    glVertex3i (1,0,0);
    glEnd();
   }

  if (DRAWHYPERPLANE)
   {
    glColor3f (0.9, 0.9, 0.9);	/* light grey */
/*     glPolygonMode (GL_FRONT_AND_BACK, GL_FILL); */
    glBegin (GL_POLYGON);
    glVertex3f (0, 1.75, -1.75);
    glVertex3f (0, 1.75, 1.75);
    glVertex3f (0, -1.75, 1.75);
    glVertex3f (0, -1.75, -1.75);
    glEnd();
   }

  if (DRAWSOURCEPERTURBPT)
   {
    glColor3f (0,0,0);		/* black qNew */
    glBegin (GL_POINTS);
    glVertex3f (qNew[0], qNew[1], qNew[3]);
    glEnd();
   }

  if (DRAWDATAPTS) {
    glColor3f (0.0, 0.0, 1.0);	/* blue */
    glBegin (GL_POINTS);
      for (i=0; i<n; i++)
	glVertex3f (pt[i][0], pt[i][1], pt[i][3]);  /* project to x3=0 in original space */
    glEnd();
  }

  if (DRAWPERTURBPTS) {
    glColor3f (0.0, 1.0, 0.0);	/* green */
    glBegin (GL_POINTS);
      for (i=0; i<n; i++)
	glVertex3f (perturbpt[i][0], perturbpt[i][1], perturbpt[i][3]);  /* project to x3=0 in original space */
    glEnd();
    glColor3f (0.0, 0.0, 0.0);	/* black */
    glBegin (GL_LINE_STRIP);
      for (i=0; i<n; i++)
	glVertex3f (perturbpt[i][0], perturbpt[i][1], perturbpt[i][3]);  /* project to x3=0 in original space */
    glEnd();
  }

  if (DRAWIMAGEPTS) {
    glColor3f (1.0, 0.0, 0.0);	/* red */
    for (i=0; i<n; i++)
     {
      glPushMatrix();
      glTranslatef (imagept[i][0], imagept[i][2], imagept[i][3]); /* project to x2=0 in image space */
      glutWireCube (.02);
      glPopMatrix();
     }
  }

  if (DRAWIMAGEPTS2) {
    glColor3f (0.0, 0.0, 0.0);	/* black */
    for (i=0; i<n; i++)
     {
      glPushMatrix();
      glTranslatef (imagept2[i][0], imagept2[i][1], imagept2[i][3]); /* project to x3=0 in image space */
      glutWireCube (.02);
      glPopMatrix();
     }
  }

  if (DRAWIMAGELINES) {
    glColor3f (0.0, 0.0, 0.0);	/* black */
    glEnable (GL_LINE_STIPPLE);
    glBegin (GL_LINES);
    for (i=0; i<n; i++)
     {
      glVertex3f (1., 0., 0.);
      glVertex3f (imagept2[i][0], imagept2[i][1], imagept2[i][3]); /* project to x3=0 in image space */
     }
    glEnd();
    glDisable (GL_LINE_STIPPLE);
  }

  if (DRAWIMAGECURVE) {
    glColor3f (1.0, 0.0, 0.0);	/* red */
    glLineWidth (2.0);
    glBegin (GL_LINE_STRIP);
      for (i=0; i<imageBez.L * PTSPERBEZSEGMENT + 1; i++)
	glVertex3f (imageCurveDisplay[i][0], 	  /* project to x2=0 in image space */
		    imageCurveDisplay[i][2],
		    imageCurveDisplay[i][3]);
    glEnd();
  }

  if (DRAWIMAGECURVE2) {
    glColor3f (0.0, 0.0, 0.0);	/* black */
    glLineWidth (2.0);
    glBegin (GL_LINE_STRIP);
      for (i=0; i<imageBez2.L * PTSPERBEZSEGMENT + 1; i++)
	glVertex3f (imageCurveDisplay2[i][0], 	  /* project to x3=0 in image space */
		    imageCurveDisplay2[i][1],
		    imageCurveDisplay2[i][3]);
    glEnd();
  }

  if (DRAWS3CURVE) {
    glColor3f (0.0, 0.0, 1.0);	/* blue */
    glLineWidth (4.0);
    glBegin (GL_LINE_STRIP);
    for (i=0; i<S3curve.L * PTSPERBEZSEGMENT + 1; i++)
	glVertex3f (S3curveDisplay[i][0], 	  /* project to x3=0 in orig space */
		    S3curveDisplay[i][1],
		    S3curveDisplay[i][3]);
    glEnd();
  }

  if (DRAWPERTURBS3CURVE) {
    glColor3f (1.0, 0.3, 0.3);	/* orange */
    glLineWidth (4.0);
    glBegin (GL_LINE_STRIP);
      for (i=0; i<perturbS3curve.L * PTSPERBEZSEGMENT + 1; i++)
	glVertex3f (perturbS3curveDisplay[i][0], 	  /* project to x3=0 in orig space */
		    perturbS3curveDisplay[i][1],
		    perturbS3curveDisplay[i][3]);
    glEnd();
  }

  if (DRAWPERTURBS3CURVE2) {
    glColor3f (0.0, 0.0, 0.0);	/* black */
    glLineWidth (4.0);
    glBegin (GL_LINE_STRIP);
      for (i=0; i<perturbS3curve2.L * PTSPERBEZSEGMENT + 1; i++)
	glVertex3f (perturbS3curveDisplay2[i][0], 	  /* project to x3=0 in orig space */
		    perturbS3curveDisplay2[i][1],
		    perturbS3curveDisplay2[i][3]);
    glEnd();
  }

  if (DRAWS3CTLPOLY) {
    glColor3f (0.5, 0.5, 1.0);  /* light blue */
    glLineWidth (2.0);
    glBegin (GL_LINE_STRIP);
    for (i=0; i<=S3curve.d * S3curve.L; i++)
      glVertex3f (S3curve.x1[i], S3curve.x2[i], S3curve.x4[i]);  /* to x3=0 */
    glEnd();
  }

  if (DRAWPERTURBS3CTLPOLY) {
    glColor3f (0.5, 1.0, 0.5);  /* light green */
    glLineWidth (2.0);
    glBegin (GL_LINE_STRIP);
      for (i=0; i<=perturbS3curve.d * perturbS3curve.L; i++)
	glVertex3f (perturbS3curve.x1[i], perturbS3curve.x2[i], perturbS3curve.x4[i]);  /* to x3=0 */
    glEnd();
  }

  if (DRAWIMAGECTLPOLY) {
    glColor3f (1.0, 0.5, 0.5);  /* light red */
    glLineWidth (2.0);
    glBegin (GL_LINE_STRIP);
      for (i=0; i<=imageBez.d * imageBez.L; i++)
	glVertex3f (imageBez.x1[i], imageBez.x3[i], imageBez.x4[i]); /* to x2=0 */
    glEnd();
  }

  if (DRAWFIGURE)
   {
    glColor3f (0, 0, 0);
    glBegin (GL_LINE_LOOP);
    glVertex3f (1.75, -1.75, 0);
    glVertex3f (1.75, 1.75, 0);
    glVertex3f (-1.75, 1.75, 0);
    glVertex3f (-1.75, -1.75, 0);
    glEnd();
    
    glColor3f (0,0,0);
    glBegin (GL_POINTS);
    glVertex3f (0,0,1);
    glVertex3f (.4, sqrt (.68), .4);
    glVertex3f (.4/.6, sqrt(.68)/.6, 0);
    glEnd();

    glEnable (GL_LINE_STIPPLE);
    glBegin (GL_LINES);
    for (i=0; i<n; i++)
     {
      glVertex3f (0,0,1);
      glVertex3f (.4/.6, sqrt(.68)/.6, 0);
    }
    glEnd();
    glDisable (GL_LINE_STIPPLE);
   }

  glPopMatrix();
  glutSwapBuffers ();
}

/******************************************************************************
	Rotate the input points so that none is at the pole.

	Check if any point is the pole (1,0,0,0).
	If yes, compute a point Q_{new} not equal to any of the input points,
	as follows: find closest point Qc to first point Q1;
	set Q_{new} = midpoint (Q1,Qc) on sphere.
	Rotate sphere so that Qnew becomes the pole.
	This will move all input points away from pole.
	This is an O(n) procedure, which is optimal for finding a point
	not in the input.

	WRONG: Note that to rotate a quaternion q to (1,0,0,0)
	is particularly easy since (1,0,0,0) is the identity quaternion:
	it suffices to multiply the quaternion by q^{-1}.
	MULTIPLICATION OF A POINT IN 4-SPACE (or 3-space for that matter)
	BY A QUATERNION DOES NOT RESULT IN ROTATION OF THE POINT
	BY THE ASSOCIATED QUATERNION ROTATION.
	Thus, the perturbing rotation is q -> q_new^{-1} * q
	and the restoring rotation is q -> q_new * q.

	To rotate a unit quaternion q to the x-axis (1,0,0,0),
	we use a 4-space rotation matrix:

		| v		|
	M = 	| unit (w1)	|
		| unit (w2)	|
		| unit (w3)	|

	where w1 = v   x   (0,0,1,0)   x   (1,0,0,0)
	      w2 = v   x   (1,0,0,0)   x    w1
	      w3 = v   x   w1  	       x    w2.
	If v lies in x3=0, M is a rotation about the x3-axis
	that maps points in x3=0 to points in x3=0.
	Here we are assuming that v is not e1 or e3: if it is, a trivial
	rotation matrix can be used.
		
******************************************************************************/

static int PerturbOld (int n, V4r *pt, V4r *perturbpt, REAL RestoringRotation[4][4])
{
  int i,j;
  int ptAtPole = 0;	/* is there an input point at the pole? */
  V4r Pole = {1,0,0,0};
  V4r closestPt;	/* closest point to first input point */
  REAL dist;		/* distance of this closest point */
  V4r  qNew;		/* point to be mapped to pole */
  V4r  e1 = {1,0,0,0};
  V4r  e3 = {0,0,1,0};
  V4r  w1,w2,w3;
  REAL M[4][4];
 
  /* is perturbation necessary? */	
  for (i=0; i<n; i++)
    if (Equal4r(pt[i], Pole))
     {
      ptAtPole = 1;
      break;
     }
  if (!ptAtPole)
    return (0);		/* no perturbation */

  /* find closest point to pt[0] */
  Copy4r (closestPt, pt[1]);
  dist = Dist4r (pt[0], pt[1]);
  for (i=2; i<n; i++)
    if (Dist4r (pt[0], pt[i]) < dist)
     {
      Copy4r (closestPt, pt[i]);
      dist = Dist4r(pt[0], pt[i]);
     }
  
  AddNew4r (pt[0], closestPt, qNew); 	/* midpoint between pt[0] and closestPt */
  Unit4r (qNew, qNew);
			
			/* compute rotation matrix */
  Copy4r (M[0], qNew);
  TripleCrossProduct (qNew, e1,   e3,   M[1]);
  TripleCrossProduct (qNew, e1,   M[1], M[2]);
  TripleCrossProduct (qNew, M[1], M[2], M[3]);
  for (i=1; i<4; i++)
    Unit4r (M[i], M[i]);

printf("Rotation matrix:\n");
for (i=0; i<4; i++)
 {
  for (j=0; j<4; j++)
    printf("%f  ", M[i][j]);
  printf("\n");
 }
  
			/* map all points under this rotation matrix */
  for (i=0; i<n; i++)
    MultMatrix4r (M, pt[i], perturbpt[i]);

printf("Perturbing input...\n");
for (i=0; i<n; i++)
  printf("pt[%i]: (%f,%f,%f,%f)\n", i, pt[i][0], pt[i][1], pt[i][2], pt[i][3]);
for (i=0; i<n; i++)
  printf("perturbpt[%i]: (%f,%f,%f,%f)\n", i, perturbpt[i][0], 
		perturbpt[i][1], perturbpt[i][2], perturbpt[i][3]);

  			/* compute M^{-1} = M^t, the restoration matrix */
  for (i=0; i<4; i++)
    for (j=0; j<4; j++)
      RestoringRotation[i][j] = M[j][i];

  return (1);
}

/******************************************************************************
	Rotate the input points as far away from pole (1,0,0,0) as possible.
        Compute minimum eigenvector of covariance matrix of the input points
	on the quaternion sphere
        This represents the minor axis of the best-fitting
        ellipsoid, and thus the normal of the best-fitting plane.
	In particular, if we rotate this point, q_new, to the pole
	then the input points are pushed far away from the pole,
	in the least-squares optimal sense.
	(Thus, outliers could still be close to the pole!!  PROBLEM)

	Since for visualization we are using input quaternions with q3=0,
	the minimum eigenvector will always be (0,0,1,0),
	so we use the 2nd smallest eigenvector in this code.

	To rotate a unit quaternion v to the x-axis (1,0,0,0),
	we use a 4-space rotation matrix:

		| v		|
	M = 	| unit (w1)	|
		| unit (w2)	|
		| unit (w3)	|

	where w1 = v   x   (0,0,1,0)   x   (1,0,0,0)
	      w2 = v   x   (1,0,0,0)   x    w1
	      w3 = v   x   w1  	       x    w2.
	If v lies in x3=0, M is a rotation about the x3-axis
	that maps points in x3=0 to points in x3=0.
	Here we are assuming that v is not e1 or e3: if it is, a trivial
	rotation matrix can be used.
		
******************************************************************************/

static void Perturb (int n, V4r *pt, V4r *perturbpt, REAL RestoringRotation[4][4])
{
  int i,j;
  V4r Pole = {1,0,0,0};
  V4r  e1 = {1,0,0,0};
  V4r  e3 = {0,0,1,0};
  V4r  w1,w2,w3;
  REAL M[4][4];
  V4r  qNewImage;

  if (VISUALIZE)
    minNonZeroEigenvectorCovMatrix4r (pt, n, qNew);
  else
    minEigenvectorCovMatrix4r (pt, n, qNew); 
 
/*  Copy4r (qNew, e1);	 *//* force no perturbation */

	if (DEBUG)
	  printf("qNew: (%f,%f,%f,%f)\n", qNew[0], qNew[1], qNew[2], qNew[3]);

			/* compute rotation matrix */
  for (i=0; i<4; i++)
    for (j=0; j<4; j++)
      M[i][j] = 0.0;

  if (Equal4r(qNew, e1))	/* identity matrix */
    M[0][0] = M[1][1] = M[2][2] = M[3][3] = 1.0;
  else if (Equal4r (qNew, e3))
    M[0][2] = M[1][1] = M[2][0] = M[3][3] = 1.0;
  else
   {
    Copy4r (M[0], qNew);
    TripleCrossProduct (qNew, e1,   e3,   M[1]);
    TripleCrossProduct (qNew, e1,   M[1], M[2]);
    TripleCrossProduct (qNew, M[1], M[2], M[3]);
    for (i=1; i<4; i++)
      Unit4r (M[i], M[i]);
   }

	if (DEBUG)
	 {
	  printf("Rotation matrix:\n");
	  for (i=0; i<4; i++)
	   {
	    for (j=0; j<4; j++)
	      printf("%f  ", M[i][j]);
	    printf("\n");
	   }
	 }

  MultMatrix4r (M, qNew, qNewImage);
  if (!Equal4r(qNewImage,Pole))
    FatalError ("Source of perturbation not mapped to pole.\n");
 			
			/* map all points under this rotation matrix */
  for (i=0; i<n; i++)
    MultMatrix4r (M, pt[i], perturbpt[i]);

	if (DEBUG)
	 {
	  printf("Perturbing input...\n");
	  for (i=0; i<n; i++)
	    printf("perturbpt[%i]: (%f,%f,%f,%f)\n", i, perturbpt[i][0], 
		perturbpt[i][1], perturbpt[i][2], perturbpt[i][3]);
	 }

  			/* compute M^{-1} = M^t, the restoration matrix */
  for (i=0; i<4; i++)
    for (j=0; j<4; j++)
      RestoringRotation[i][j] = M[j][i];
}

/******************************************************************************/
/******************************************************************************/

int main(int argc, char **argv)
{
  FILE  *fp;
  int   ArgsParsed=0;
  int   i,j;
  float angle, axis[3], unitaxis[3];
  REAL  RestoringRotation[4][4];
  REAL  minDist;		/* minimum distance of input point from pole */
  V4r   Pole = {1,0,0,0};
  V4r   ctrlpt, newctrlpt;
  V4r   dpt,pt1,imageTang;
  V3r   foo, bar, foobar;
  REAL  y,y2,dy;
  
  RoutineName = argv[ArgsParsed++];
  while (ArgsParsed < argc)
    if ('-' == argv[ArgsParsed][0])
      switch (argv[ArgsParsed++][1])
       {
	case 'i':	INPUTANGLEAXIS = 1;	break;
	case 'v':	VISUALIZE = 1; 		break;
	case 'r':	RANDOMINPUT = 1;	break;
	case 'n': 	n = atoi(argv[ArgsParsed++]);
			NPTKNOWN = 1;		break;
        case 'h': 
	default: 
		usage(); exit(-1);
       }
    else {usage(); exit(-1);}
 
  /************************************************************/

  if (RANDOMINPUT)
   {
    srand(time(0));
    if (NPTKNOWN)
      if (n<2) FatalError ("Need at least two input points\n");
    else
      n = rand() % 98 + 3; 	/* generate 3 to 100 points */
		printf("Input is %i random points.\n", n);
		printf("Angular difference between consecutive points ");
		printf("is bounded at %f radians.\n", MAXANGLEDIFF);
		printf("These points have been output to the file `random.dat'.\n");
    pt = (V4r *) malloc (n * sizeof(V4r));
    for (i=0; i<n; i++)	   /* generate random pts, at most MAXANGLEDIFF apart */
      do
       {
        for (j=0; j<4; j++)
          pt[i][j] = myRand();	/* random number in [-1,1] */
        Unit4r (pt[i], pt[i]);
       }
      while (SphericalDist4r (pt[i], pt[i==0?0:i-1]) > MAXANGLEDIFF);
    fp = fopen ("random.dat", "w");
    fprintf (fp,"%i\n", n);
    for (i=0; i<n; i++)
      fprintf(fp,"%f %f %f %f\n", pt[i][0], pt[i][1], pt[i][2], pt[i][3]);
    fclose(fp);
   }
  else
   {
    fscanf (stdin, "%i", &n);
    if (n < 2) FatalError ("Need at least two input points\n");
    pt = (V4r *) malloc (n * sizeof(V4r));
    if (INPUTANGLEAXIS)
      for (i=0; i<n; i++)
       {
        fscanf (stdin, "%f %f %f %f", &angle, axis, axis+1, axis+2);
        angle = deg2radians(angle);
        pt[i][0] = cos(angle/2);
        Unit (axis, unitaxis);
        SMult (unitaxis, sin(angle/2), axis);
        for (j=0; j<3; j++)
          pt[i][j+1] = axis[j];
       }
    else
      for (i=0; i<n; i++)
        scanf ("%f %f %f %f", pt[i], pt[i]+1, pt[i]+2, pt[i]+3);

    /* test that input meets sampling criterion: no large gaps */
    for (i=0; i<n-1; i++)
      if (SphericalDist4r (pt[i], pt[i+1]) > MAXANGLEDIFF)
       {
        printf("(%f,%f,%f,%f) and (%f,%f,%f,%f) at distance %f = %f degrees.\n",
		  pt[i][0], pt[i][1], pt[i][2], pt[i][3], 
		  pt[i+1][0], pt[i+1][1], pt[i+1][2], pt[i+1][3], 
		  SphericalDist4r (pt[i], pt[i+1]),  
		  radian2deg (SphericalDist4r (pt[i], pt[i+1])));
        FatalError ("Unacceptable gap between consecutive quaternions.\n");
       }
   }
  if (VISUALIZE)
   {
    printf("Transforming input to x3=0 hyperplane for visualization...\n");
    for (i=0; i<n; i++)
     {
      pt[i][2] = 0;
      Unit4r (pt[i], pt[i]);
     }
   }

	if (DEBUG)
	  for (i=0; i<n; i++)
	    printf("pt[%i]: (%f,%f,%f,%f)\n", i, pt[i][0], pt[i][1], pt[i][2], pt[i][3]);

	/* perturb input away from (1,0,0,0) pole */
  perturbpt = (V4r *) malloc (n * sizeof(V4r));
  Perturb (n, pt, perturbpt, RestoringRotation);

	/* test minimum distance from pole */
	/* observation: if there are enough points scattered widely across */
	/* the sphere, it can turn out that there is NO perturbation that */
	/* moves all input sufficiently far from the pole */
  minDist = 5;
  for (i=0; i<n; i++)
    if (SphericalDist4r (perturbpt[i], Pole) < minDist)
      minDist = SphericalDist4r (perturbpt[i], Pole);
  if (DEBUG)
    printf("Closest point to pole after perturbation is at distance %f = %f degrees.\n", 
		minDist, radian2deg(minDist));

	/* if min dist to pole is too small, (sub)divide input and conquer, */
	/* with care to splice subcurves together smoothly */
/*  if (minDist < TOOCLOSETOPOLE) */
    

  	/* to image space */
  imagept = (V4r *) malloc (n * sizeof(V4r));
  for (i=0; i<n; i++)
    invM (perturbpt[i], imagept[i]);
  imagept2 = (V4r *) malloc (n * sizeof(V4r));
  for (i=0; i<n; i++)
    SP (perturbpt[i], imagept2[i]);

	if (DEBUG)
	  for (i=0; i<n; i++)
            printf("imagept[%i]: (%f,%f,%f,%f)\n", 
		i, imagept[i][0], imagept[i][1], imagept[i][2], imagept[i][3]);

  	/* image curve */
/*  FitCubicBez_4d (n, imagept, &imageBez); */
  srand(time(0));
  for (j=0; j<4; j++)	/* random tangent at first input point */
    dpt[j] = myRand();	/* dpt is derivative of pt */
		/* tangent must be in plane orthogonal to vector to 1st input pt */
  if (VISUALIZE)  dpt[2] = 0;
  /* assuming VISUALIZE: cross product of 3 vectors to get in tangent plane */
  foo[0] = perturbpt[0][0]; foo[1] = perturbpt[0][1]; foo[2] = perturbpt[0][3];
  bar[0] = dpt[0]; 	    bar[1] = dpt[1];	      bar[2] = dpt[3];
  Cross (foo, bar, foobar);
  dpt[0] = foobar[0]; dpt[1] = foobar[1]; dpt[2] = 0; dpt[3] = foobar[2];
  if (DEBUG) printf("Trying to set beginning tangent on sphere to (%f,%f,%f,%f)...\n",
		dpt[0], dpt[1], dpt[2], dpt[3]);

	/* imageTang is computed using (M^{-1})'(x(t),y(t)) */
	/* evaluated using 1st input pt and dpt */
  Copy4r (pt1, perturbpt[0]);
  y = sqrt(2 - 2 * pt1[0]);
  y2 = y*y;
  dy = (-2*dpt[0])/(2*y);
  imageTang[0] = (dpt[1]*y - pt1[1]*dy)/y2;
			/* x2'y - x2y'/y^2, where y^2 = 2-2x1 */
  imageTang[1] = (dpt[2]*y - pt1[2]*dy)/y2;
  imageTang[2] = (dpt[3]*y - pt1[3]*dy)/y2;
  imageTang[3] = (-dpt[0]*y - (1-pt1[0])*dy)/y2;
			/* -x1'y - (1-x1)y'/y^2 */
/*  FitCubicBezWithEndTangents_4d (n, imagept, imageTang, imageTang, &imageBez); */
  FitCubicBez_4d (n, imagept, &imageBez);
  CheckC2Continuity_Bez4d (&imageBez);
  PrepareBezDisplay_4d (&imageBez, &imageCurveDisplay, PTSPERBEZSEGMENT);

  FitCubicBez_4d (n, imagept2, &imageBez2);
  PrepareBezDisplay_4d (&imageBez2, &imageCurveDisplay2, PTSPERBEZSEGMENT);

  /* prep SP's image curve for application of M_curve, by shifting left */
  for (i=0; i<=imageBez2.d * imageBez2.L; i++)
   {
    imageBez2.x1[i] = imageBez2.x2[i];
    imageBez2.x2[i] = imageBez2.x3[i];
    imageBez2.x3[i] = imageBez2.x4[i];
    imageBez2.x4[i] = 1;
   }

  	/* S3 curve */
  M_curve (&imageBez, &perturbS3curve);
		/* not correct formula for tangent: haven't used knot values */
  if (DEBUG) printf("Beginning tangent on sphere is (%f,%f,%f,%f).\n",
		(6*perturbS3curve.weights[1]/perturbS3curve.weights[0])
			* (perturbS3curve.x1[1] - perturbS3curve.x1[0]),
		(6*perturbS3curve.weights[1]/perturbS3curve.weights[0])
			* (perturbS3curve.x2[1] - perturbS3curve.x2[0]),
		(6*perturbS3curve.weights[1]/perturbS3curve.weights[0])
			* (perturbS3curve.x3[1] - perturbS3curve.x3[0]),
		(6*perturbS3curve.weights[1]/perturbS3curve.weights[0])
			* (perturbS3curve.x4[1] - perturbS3curve.x4[0]));
  CheckC1Continuity_RatBez4d (&perturbS3curve);
  /* CheckC2Continuity_RatBez4d (&perturbS3curve); */ /* not correct rational check yet */
  PrepareRatBezDisplay_4d (&perturbS3curve, &perturbS3curveDisplay, PTSPERBEZSEGMENT);

  M_curve (&imageBez2, &perturbS3curve2);
  PrepareRatBezDisplay_4d (&perturbS3curve2, &perturbS3curveDisplay2, PTSPERBEZSEGMENT);
  
  		/* restore control points to unperturbed position */
  S3curve.d = 6;
  S3curve.L = perturbS3curve.L;
  S3curve.knots  = (REAL *) malloc ((S3curve.L + 1) * sizeof(REAL));
  S3curve.x1 = (REAL *) malloc ((S3curve.d * S3curve.L + 1) * sizeof(REAL));
  S3curve.x2 = (REAL *) malloc ((S3curve.d * S3curve.L + 1) * sizeof(REAL));
  S3curve.x3 = (REAL *) malloc ((S3curve.d * S3curve.L + 1) * sizeof(REAL));
  S3curve.x4 = (REAL *) malloc ((S3curve.d * S3curve.L + 1) * sizeof(REAL));
  S3curve.weights = (REAL *) malloc ((S3curve.d * S3curve.L + 1) * sizeof(REAL));

  for (i=0; i<=S3curve.L; i++)
    S3curve.knots[i] = perturbS3curve.knots[i];
  for (i=0; i<=S3curve.d * S3curve.L; i++)
   {
    ctrlpt[0] = perturbS3curve.x1[i];		/* wow! inelegant!! */
    ctrlpt[1] = perturbS3curve.x2[i];
    ctrlpt[2] = perturbS3curve.x3[i];
    ctrlpt[3] = perturbS3curve.x4[i];
    MultMatrix4r (RestoringRotation, ctrlpt, newctrlpt);
    S3curve.x1[i] = newctrlpt[0];
    S3curve.x2[i] = newctrlpt[1];
    S3curve.x3[i] = newctrlpt[2];
    S3curve.x4[i] = newctrlpt[3];
    S3curve.weights[i] = perturbS3curve.weights[i];
   }
  PrepareRatBezDisplay_4d (&S3curve, &S3curveDisplay, PTSPERBEZSEGMENT);

  printf("Net squared tangential (covariant) acceleration of S3 curve generated by M = %f\n",
	  CovariantAccel_Spherical (&perturbS3curve, NQUALITYPROBES));
  printf("Net squared tangential (covariant) acceleration of S3 curve generated by spherical projection = %f\n",
	  CovariantAccel_Spherical (&perturbS3curve2, NQUALITYPROBES)); 

  /************************************************************/

  if (VISUALIZE)
   {
  glutInitWindowPosition (0,0);
  glutInitWindowSize (500,500);
  glutInit (&argc, argv);
  glutInitDisplayMode (GLUT_RGB | GLUT_DOUBLE | GLUT_DEPTH);
  glutCreateWindow ("Rational S3 curves");
  glutDisplayFunc (display);
  glutKeyboardFunc (keyboard);
  glutMouseFunc (mouse);
  glutMotionFunc (motion);
  glutReshapeFunc (reshape);
  glutVisibilityFunc (visibility);
  gfxinit();
  glutCreateMenu (menu);
  glutAddMenuEntry ("Input points", 1);
  glutAddMenuEntry ("Source of perturbation", 2);
  glutAddMenuEntry ("Perturbed input points", 3);
  glutAddMenuEntry ("Image points", 4);
  glutAddMenuEntry ("Image curve", 5);
  glutAddMenuEntry ("Image curve control polygon", 6);
  glutAddMenuEntry ("Perturbed S3 curve", 7);
  glutAddMenuEntry ("Perturbed S3 curve control polygon", 8);
  glutAddMenuEntry ("S3 curve", 9); 
  glutAddMenuEntry ("S3 curve control polygon", 10); 
  glutAddMenuEntry ("Image points under SP", 11); 
  glutAddMenuEntry ("Image curve under SP", 12);
  glutAddMenuEntry ("Perturbed S3 curve under SP", 13);
  glutAddMenuEntry ("Hyperplane", 14);
  glutAddMenuEntry ("Image lines", 15);
  glutAddMenuEntry ("Pole", 16);
  glutAddMenuEntry ("Figure", 17);
  glutAttachMenu (GLUT_RIGHT_BUTTON);
  glutMainLoop();
   }
  return 0;             /* ANSI C requires main to return int. */
}

