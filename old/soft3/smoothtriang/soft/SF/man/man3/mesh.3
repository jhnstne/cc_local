.TH mesh 3
.SH NAME
MeshParse, WriteMesh, WriteItoEMesh, BoundaryEdge, BoundaryVertex,
BoundaryFace, ForeachMeshFace, ForeachMeshVertex, ForeachMeshEdge,
ForeachFaceVertex, ForeachFaceEdge,
ForeachVertexFace, ForeachVertexEdge, ForeachVertexVertex, 
EndForeach, GetEdgeVertices, GetVertexEdge, GetEdgeFaces,
SetInternalData,ReturnInternalData,SetName,ReturnName
\- mesh operations
.SH SYNTAX
.nf
.B #include "geometry.h"
.B #include "userData.h"
.B #include <mesh.h>
.PP
.B Mesh* MeshParse(fp)
.B FILE* fp;
.PP
.B void WriteMesh(m,fp)
.B Mesh* m;
.B FILE* fp;
.PP
.B void WriteItoEMesh(m, fp, itoeV, itoeE, itoeF)
.B Mesh* m;
.B FILE* fp;
.B void* (*itoeV)();
.B void* (*itoeE)();
.B void* (*itoeF)();
.PP
.B void ClearMeshExternalData(m)
.B Mesh* m;
.PP
.B BOOLEAN BoundaryEdge(e)
.B Edge* e;
.PP
.B BOOLEAN BoundaryVertex(v)
.B Vertex* v;
.PP
.B BOOLEAN BoundaryFace(f)
.B Face* f;
.PP 
.B Vertex* VertexPath(v1,v2,p)
.B Vertex* v1;
.B Vertex* v2;
.B char* p;
.PP
.B ForeachMeshFace(m,f)
.B Mesh* m;
.B Face* f;
.PP 
.B ForeachMeshVertex(m,v)
.B Mesh* m;
.B Vertex* v;
.PP 
.B ForeachMeshEdge(m,e)
.B Mesh* m;
.B Edge* e;
.PP 
.B ForeachFaceVertex(f,v)
.B Face* f;
.B Vertex* v;
.PP 
.B ForeachFaceEdge(f,e)
.B Face* f;
.B Edge* e;
.PP 
.B ForeachFaceFace(f1,f2)
.B Face* f1;
.B Face* f2;
.PP 
.B ForeachVertexFace(v,f)
.B Vertex* m;
.B Face* f;
.PP 
.B ForeachVertexEdge(v,e)
.B Vertex* m;
.B Edge* f;
.PP 
.B ForeachVertexVertex(v1,v2)
.B Vertex* v1;
.B Vertex* v2;
.PP 
.B void GetVertexEdge(v1,v2,e)
.B Vertex* v1;
.B Vertex* v2;
.B Edge** e;
.PP
.B GetEdgeVertices(e,v1,v2)
.B Edge* e;
.B Vertex** v1;
.B Vertex** v2;
.PP
.B GetEdgeFaces(e,f1,f2)
.B Edge* e;
.B Face** f1;
.B Face** f2;
.PP
.B GetFaceEdge(f1,f2,e)
.B Face* f1;
.B Face* f2;
.B Edge** e;
.PP
.B GetVertexFaceEdge(v, f, e)
.B Vertex* v;
.B Face* f;
.B Edge** e;
.PP
.B SetInternalData(v, d)
.B Vertex* v;
.B void* d;
.PP
.B void* ReturnInternalData(v)
.B Vertex* v;
.PP
.B SetName(v, n)
.B Vertex* v;
.B char* n;
.PP
.B ReturnName(v, n)
.B Vertex* v;
.B char* n;
.fi
.SH DESCRIPTION
Mesh is a library to manipulate topological data structures.
Currently, meshes can be read in, traversed, and written.
The mesh package does NOT handle any geometry.  A separate
package is provided to allow certain geometric operations.
See userdata(3).

The mesh library also doesn't allow for the modification of
meshes.  This is handled in the library operators(3).  Note
that some of the iterators below will have problems if the
mesh is modified in the middle of an iteration.

.PP
The
.B MeshParse()
routine reads in a mesh from a file, and returns a pointer to
a mesh structure.  Note that this "routine" is really a macro.

Each time MeshParse() (or another from its family) is called, the
next mesh in the file is read.  Note that each point and faces may
only occur in one mesh.  Any point or face not used in a mesh will
remain defined for the next mesh that is read.

See also MeshUDParse (userdata 3).
.PP
The
.B WriteMesh()
routine writes a mesh to the given file.  Note that if the internal
data fields have been modified, then a call to ConvertGeometryToExternal()
should be made to flush them to the dstructs.
A more memory efficient approach is to call
.B WriteItoEMesh().
The routine takes three procedures that convert the internal format
to the external format while writing, free the external space after
is is printed.  See userdata 3 for a default set of 
.B itoe 
routines.

.B ClearMeshExternalData()
clears the external data fields of a mesh.
.PP
The routines
.B BoundaryEdge(), BoundaryVertex(),
and
.B BoundaryFace()
return TRUE if the parameter is an object of the appropriate type
that lies on the boundary of the mesh.  A face is said to lie
on the boundary if any of its edges or vertices lie on the
boundary.
.PP
The routine
.B VertexPath()
walks a path through the mesh.  The path starts at
.I v1.
It next moves to 
.I v2.
This gives us a vertex and an edge (the edge from
.I v1
to
.I v2
).  Our path will be a string of integers, separated by spaces.
From 
.I v2,
we will label the edges in a counter clockwise fashion, giving the
label 0 to the edge from
.I v1
to 
.I v2.
At each successive vertex in the path, the edge the vertex was entered
from will be labeled 0.  By specifing negative numbers, one may move
in the clockwise direction.  If a number is larger than the number of
vertices in the path, then the count "wraps".  Boundaries are skipped
over.  If
.I v2
is not adjacent to
.I v1,
a NULL pointer is returned.  Otherwise, the last vertex in the path
is returned.
.PP
The "routines"
.B ForeachMeshFace(), ForeachMeshVertex(), ForeachMeshEdge(),
.B ForeachVertexFace(), ForeachVertexFace(), ForeachFaceVertex(), 
.B ForeachFaceEdge(), ForeachFaceFace(),
and
.B ForeachVertexVertex()
are macros that allow iteration over various parts of the mesh.
The type of iteration is determined by the name: the first part
is what is iterated around, while the second part is what is
iterated over.  For example, 
.B ForeachMeshVertex()
will give each vertex in the mesh.  
Each loop is terminated by the macro
.B EndForeach.
Iterators which iterator around an object in the mesh will iterate
in counter-clockwise order.  The current object will be stored in
the second parameter to the 
.B Foreach.
The first object in the iteration is arbitrary, unless the object
iterated around is on the boundary.  In this case, the iteration
will start at one part of the boundary and end at the other part.
A local variable,
.B iter,
is used as a loop control variable.

The routine
.B GetEdgeVertices()
gets both of the vertices associated with an edge.
The routine
.B GetVertexEdge()
finds the directed edge associated with two vertices.
If the edge doesn't exist, the edge pointer is set to NULL.
.B GetEdgeFaces()
gets the two faces neighboring an edge.  If the edge is a boundary
edge, then the second face will be set to NULL.
.B GetFaceEdge()
finds the edge between the two faces.  If the edge doesn't exist,
the edge pointer is set to NULL.
.B GetVertexFaceEdge()
finds the edge bounding f leaving v in a counter clockwise direction.
If v is not on f, then the edge pointer will be set to NULL.

NOTE: If you forget an EndForeach, you will get strange error
messages.  Most commonly, you'll get a syntax error at the
start of the next procedure or at the end of the file.

NOTE: ForeachVertexEdge returns all the edges pointing to a particular
vertex.  This means that, for boundary vertices, the boundary half edge 
directed away from the vertex will not be included in the iteration.

.SH EXAMPLE
The following code reads in a mesh, and prints out the names of
all the faces followed by the ring of vertices around each face.

.EX
	m = MeshParse(stdin);
	ForeachMeshFace(m,f)
		printf("face %s: ",ReturnName(f));
		ForeachFaceVertex(f,v)
			printf(" %s ",ReturnName(v));
		EndForeach
		printf("\\n");
	EndForeach
.EE

.SH NOTES
This is an early version, and is subject to change.
.PP
Send bugs/requests to smann@june.

.SH SEE ALSO
userdata(3), operators(3)

.SH DATE
November 10, 1991
