/*
 * Copyright (c) 1990, Graphics and AI Laboratory, University of Washington
 * Copying, use and development for non-commercial purposes permitted.
 *                  All rights for commercial use reserved.
 */

/*
 *----------------------------------------------------------------------
 *  File:  kcurve.c
 *----------------------------------------------------------------------
 */

#include <stdio.h>
#include "all.h"
#include "curve.h"
#include <math.h>
#include "sff.h"

#define EPS 0.000000001

typedef Curve BezierCurve;

typedef struct {
  Point p;
  Vector v;
  double k; /* curvature */
} Kdata;






/*
 *----------------------------------------------------------------------
 *  Function:  VVScalarCrossProduct
 *----------------------------------------------------------------------
 */
Scalar VVScalarCrossProduct(v1,v2)
Vector v1,v2;
{
  Scalar x1,y1,x2,y2;

  VCoords(v1,StdFrame(SpaceOf(v1)), &x1,&y1);
  VCoords(v2,StdFrame(SpaceOf(v2)), &x2,&y2);
  return ( x1*y2 - x2*y1 );
}

/*
 *----------------------------------------------------------------------
 *  Function:  ComputeDeltas
 *	Compute the delta values given in deBoor, Hollig, Sabin.
 *----------------------------------------------------------------------
 */
void ComputeDeltas(d0,d1,a,k0,k1, nd,delta0,delta1)
Vector d0,d1,a;
int* nd;
Scalar k0,k1,delta0[],delta1[];
{
  Scalar d0Xd1;
  Scalar R0,R1;

  d0Xd1 = VVScalarCrossProduct(d0,d1);

  if ( fabs(d0Xd1) < 0.0000001 ) { 

    if (VVScalarCrossProduct(a,d1)/k1 <= 0.0  || /* should use epsilon */
	VVScalarCrossProduct(d0,a)/k0 <= 0.0 ) { /* should use epsilon */
      fprintf(stderr,"CreateCurve: curvature incompatible w/data.\n");
      *nd = 0;
      return;
    }
    delta1[0] = sqrt( VVScalarCrossProduct(a,d1)/k1 * 2.0/3.0 );
    delta0[0] = sqrt( VVScalarCrossProduct(d0,a)/k0 * 2.0/3.0 );
    *nd = 1;

  } else {

    double C[5];/* coeff for Quartic Polynomial for QuarticRoots()
		   Expects coeff from high degree to low degree.
		   Also assumes first coeff is 1, and not passed.
		   We will solve for delta1, and plug in to get delta0 */
    double r[4];/* the roots */
    int nr;	/* the number of roots */
    double aXd1,d0Xa;
    int i;

    aXd1 = VVScalarCrossProduct(a,d1);
    d0Xa = VVScalarCrossProduct(d0,a);

    C[0] = 27.0/8.0 * k0 * k1*k1 / (d0Xd1 * d0Xd1);
    C[1] = 0.0;
    C[2] = -4.5 * k0*k1 * aXd1 / (d0Xd1 * d0Xd1);
    C[3] = d0Xd1;
    C[4] = -d0Xa + (1.5*k0 * aXd1*aXd1/ (d0Xd1 * d0Xd1));
    for(i=1; i<=4; i++){
      C[i] /= C[0];
    }

/* sanity check */
R0 = 1.5*k0*aXd1*aXd1/(d0Xa*d0Xd1*d0Xd1);
R1 = 1.5*k1*d0Xa*d0Xa/(aXd1*d0Xd1*d0Xd1);

/*
fprintf(stderr,"R0 = %g, R1 = %g\n",R0,R1);
*/


    QuarticRoots(C+1,&nr,r);

    *nd = 0;
    for(i=0;i<nr;i++){
      if ( r[i] > 0.0 ){
	delta1[*nd] = r[i];
	delta0[*nd] = (VVScalarCrossProduct(a,d1) - 
		   3.0/2.0 * k1 * delta1[*nd] * delta1[*nd])/d0Xd1;
	if ( delta0[*nd] > 0.0 ) {
	  *nd += 1;
	}
      }
    }
  }
}

/*
 *----------------------------------------------------------------------
 *  Function:  CreateCurve
 *	Use method in deBoor, Hollig and Sabin, ``High accuracy geometric
 *  Hermite interpolation'', CAGD 4 (1987) 269-278.
 *
 *  Parameters:
 *	int which - select a delta pair (computed mod number of pairs).
 *  Return Value:
 *	int 	- the number of delta pairs
 *
 *  Notes:
 *	Here we don't have to worry about the direction of the curve.
 *  If we use this in a surface scheme, we'll need to make sure we
 *  can orient curves in unique fashion.
 *----------------------------------------------------------------------
 */
int CreateCurve(v0,v1,c,which)
Kdata* v0;
Kdata* v1;
BezierCurve* c;
int which;
{
  Vector d0,d1;
  Vector a;
  Scalar delta0[4], delta1[4];
  int nd;	/* the number of positive delta pairs */
  Scalar k0,k1;
  Scalar d0Xd1;
  int i;
  void PrintKdata();
  void PrintCurve();
  /* these next four variables are used to pick a pair of deltas */
  Point c1[4];
  Point c2[4];
  Scalar rw,rc;

  c->degree = 3;
  c->cp[0] = v0->p;
  c->cp[3] = v1->p;
  k0 = v0->k;
  k1 = v1->k;

  d0 = v0->v;
  d1 = v1->v;
  a = PPDiff(v1->p,v0->p);


  ComputeDeltas(d0,d1,a,k0,k1,&nd,delta0,delta1);

  if ( nd == 0 ) {
    fprintf(stderr,"CreateCurve: No positive real delta pairs!\n");
    return 0;
  } else if ( which > 0 ) {
    which = which % nd;
  }


  /* if curve wasn't specified, select curve that makes tan's nearly equal */
  if ( which == -1 ) {
    rw = 0.0;
    for(i=0;i<nd;i++){
      rc= fabs(delta0[i]/delta1[i]);
      if ( rc > 1.0 ){
	rc = 1.0/rc;
      }
      if ( rc > rw ){
	which = i;
	rw = rc;
      }
    }
  } 
/* debug code to make sure we get "best" delta pair 
  if ( nd > 1 ) {
    for(i=0;i<nd;i++){
      fprintf(stderr,"d0 = %5.5f, d1 = %5.5f",delta0[i],delta1[i]);
      if ( i==which ){
	fprintf(stderr,"*\n");
      }	else {
	fprintf(stderr,"\n");
      }
    }
  }
*/
  
  c->cp[1] = PVAdd( c->cp[0], SVMult( delta0[which], d0) );
  c->cp[2] = PVAdd( c->cp[3], SVMult(-delta1[which], d1) );
/*
fprintf(stderr,"d0 = %g, d1 = %g\n",delta0[which],delta1[which]);
*/
  return nd;
}


/*
 *----------------------------------------------------------------------
 *  Function:  OrderData
 *	Put an ordering on two Kdata structures.  Return true if
 *  they needed to be flipped, false otherwise.
 *----------------------------------------------------------------------
 */
int OrderData(v0,v1)
Kdata** v0;
Kdata** v1;
{
  Scalar x0,y0,z0;
  Scalar x1,y1,z1;
  Kdata* tmp;

  PCoords((*v0)->p, StdFrame(SpaceOf((*v0)->p)), &x0, &y0, &z0);
  PCoords((*v1)->p, StdFrame(SpaceOf((*v0)->p)), &x1, &y1, &z1);

  if ( x1 < x0 ){
    tmp = *v0;
    *v0 = *v1;
    *v1 = tmp;
    return 1;
  } else if ( x0 < x1 ) {
    return 0;
  }

  if ( y1 < y0 ){
    tmp = *v0;
    *v0 = *v1;
    *v1 = tmp;
    return 1;
  } else if ( y0 < y1 ) {
    return 0;
  }

  if ( z1 < z0 ){
    tmp = *v0;
    *v0 = *v1;
    *v1 = tmp;
    return 1;
  } else if ( z0 < z1 ) {
    return 0;
  }

  fprintf(stderr,"OrderData: points are identical!  Not swapping.  What?  You worry?\n");
  return 0;
}




/*
 *----------------------------------------------------------------------
 *  Function:  ComputePlanarTangents
 *	Compute tangent vectors that point lie in a common plane with
 *  both specified points and each other, and lie in the given tangent
 *  planes.
 *	Vectors should both be "oriented" from p0 to p1.
 *----------------------------------------------------------------------
 */
ComputePlanarTangents(p0,n0,p1,n1,v0,v1,plane)
Point p0;
Normal n0;
Point p1;
Normal n1;
Vector* v0;
Vector* v1;
Vector* plane;
{
  Vector u1;	/* the direction from p0 to p1 */
  Vector u3;	/* the plane containing the two points and the
		   average of the two normals */
  u1 = PPDiff(p1, p0);
  u1 = VNormalize(u1);
  u3 = VVCross(u1, VVAdd(NDual(n0), NDual(n1)));
  u3 = VNormalize(u3);
  *plane = u3;

  *v0 = VVCross(NDual(n0), u3);
  *v0 = VNormalize(*v0);
  *v1 = VVCross(NDual(n1), u3);
  *v1 = VNormalize(*v1);
  
								    
  /* we may need to flip the vectors */
  if (VVDot(VVCross(NDual(n1), u3), u1) < 0.0) {
    *v0 = SVMult(-1.0, *v0);
    *v1 = SVMult(-1.0, *v1);
  }
}


/*
 *----------------------------------------------------------------------
 *  Function:  InPlane
 *	Determine if a vector is in the plane determined by the first
 *  two coordinates of a frame.
 *----------------------------------------------------------------------
 */
int InPlane(v1,f)
Vector v1;
Frame f;
{
  Scalar x,y,z;

  VCoords(v1,f,&x,&y,&z);
  if ( fabs(z) > EPS ) {
    fprintf(stderr,"InPlane: z = %g\n",z);
    return 0;
  } else 
    return 1;
}





Scalar ComputeCurvature(sff,dir,n,plane)
SFF* sff;
Vector dir;
Normal n;
Normal plane;
{
  Scalar k;

  k = -1.0 * EvalSFF(sff, VNormalize(dir));
  k = k/VMag(VVCross(VNormalize(NDual(n)),VNormalize(NDual(plane))));

  return k;
}




/*
 *----------------------------------------------------------------------
 *  Function:  deBoorHolligSabin
 *	Compute a cubic boundary curve based on the method described
 *  in "High accuracy geometric Hermite interpolation", by de Boor,
 *  Hollig, and Sabin, CAGD 4, 1987, 269-278.
 *	The required data is:
 *		two points tagged with tangents and curvature,
 *
 *  where the two points and tangents lie in a common plane.
 *	Since these curves are intended to be used as boundary
 *  curves, we must be careful that we construct the same curve,
 *  when given the same data, *even if the ordering of the data is switched*.
 *  This is achieved by putting an ordering on the two points, and in
 *  this way achieve a consistant ordering (and thus the same curve).
 *
 *  Return Value:
 *	int (really BOOLEAN)	- TRUE if curve was constructed,
 *				  FALSE if the construction failed.
 *----------------------------------------------------------------------
 */
int deBoorHolligSabin(p0,n0,sff0,p1,n1,sff1,c)
Point p0;
Normal n0;
SFF sff0;
Point p1;
Normal n1;
SFF sff1;
BezierCurve* c;
{
  static Space s=NULL;
  Frame f;
  AffineMap map;
  AffineMap mapBack;
  
  Vector v1,v2;
  Vector plane;
  Vector vx,vy;
  Point  porg;
  Vector* vp;
  Kdata tv0,tv1;
  Kdata *kd0 = &tv0,*kd1 = &tv1;
  int flip;
  double Curvature();
  static double minC=2.0, maxC=0.0;

  if ( s == NULL )
    s = SCreate("internal",2);


  ComputePlanarTangents(p0,n0,p1,n1,&kd0->v,&kd1->v,&plane);


  kd0->p = p0;
  kd1->p = p1;

  /* Sign change is due to different conventions */
  kd0->k = ComputeCurvature(&sff0, VNormalize(kd0->v), n0, VDual(plane));
  kd1->k = ComputeCurvature(&sff1, VNormalize(kd1->v), n1, VDual(plane));
/*
  kd0->k = -1.0 * EvalSFF(&sff0, VNormalize(kd0->v));
  kd1->k = -1.0 * EvalSFF(&sff1, VNormalize(kd1->v));
*/

  if ( flip = OrderData(&kd0,&kd1) ) {
    kd0->v = SVMult( -1.0, kd0->v );
    kd1->v = SVMult( -1.0, kd1->v );
    vy = VNormalize(VVDiff(NDual(n1),
			   SVMult(VVDot(NDual(n1),plane),plane)));
    porg = p1;
  } else {
    vy = VNormalize(VVDiff(NDual(n0),
			   SVMult(VVDot(NDual(n0),plane),plane)));
    porg = p0;
  }
  vx = VNormalize(kd0->v);

  /* transform to a 2d setting */
  f = FCreate("temp",porg,vx,vy,VVCross(vx,vy));

  if ( ! InPlane(PPDiff(p0,p1),f)  ||  ! InPlane(kd1->v,f) ) {
    fprintf(stderr,"deBoorHolligSabin(): points not in plane.  Proceed with caution.\n");
  }

  map = ACreate(f, FOrg(StdFrame(s)), FV(StdFrame(s),0), 
		   SVMult(-1.0,FV(StdFrame(s),1)), VZero(s) );
  mapBack = ACreate(StdFrame(s), FOrg(f), FV(f,0), SVMult(-1.0,FV(f,1)), 
		    FV(f,1)/*shouldn't need this last arg; bug in geometry package */ );

  kd0->p = PAxform( kd0->p, map );
  kd0->v = VAxform( kd0->v, map );
  kd1->p = PAxform( kd1->p, map );
  kd1->v = VAxform( kd1->v, map );

  if ( CreateCurve(kd0, kd1, c, -1) == 0 ){
    return 0;
  }

/* debug code to make sure curvature is nice 
if ( Curvature(c,0.0 ) > maxC ){
  fprintf(stderr,"Curvature @0 of %12.12f\n",maxC=Curvature(c,0.0));
}
if (  Curvature(c,0.0 )  < minC ) {
  fprintf(stderr,"Curvature @0 of %12.12f\n",minC=Curvature(c,0.0));
}
if ( Curvature(c,1.0 ) > maxC ){
  fprintf(stderr,"Curvature @1 of %12.12f\n",maxC=Curvature(c,1.0));
}
if (  Curvature(c,1.0 )  < minC ) {
  fprintf(stderr,"Curvature @1 of %12.12f\n",minC=Curvature(c,1.0));
}
*/

  /* we may need to reverse the direction of the curve */
  if ( flip ) {
    Point t;

    c->cp[0] = p0;
    t = PAxform(c->cp[1], mapBack);
    c->cp[1] = PAxform(c->cp[2], mapBack);
    c->cp[2] = t;
    c->cp[3] = p1;
  } else {
    c->cp[0] = p0;
    c->cp[1] = PAxform(c->cp[1], mapBack);
    c->cp[2] = PAxform(c->cp[2], mapBack);
    c->cp[3] = p1;
  }

  return 1;
}


void CompareToSphere(c)
Curve *c;
{
  Point p;
  int i;
  double max,dist;
  static double maxMax=0.0;
  Point EvalCurve();

  max = 0.0;
  for(i=0;i<=25;i++){
    p = EvalCurve(c,(double)i/25.0);
    dist = fabs( VMag( PPDiff( p,FOrg(StdFrame(SpaceOf(p))) ) ) - 1.0 );
    if ( dist > max )
      max = dist;
  }
  if ( max > maxMax ){
    maxMax = max;
    fprintf(stderr,"max from sphere so far is %g\n",maxMax);
  }
}


int dBHS(v1,v2,p1,p2)
Vertex* v1;
Vertex* v2;
Point* p1;
Point* p2;
{
  SFF sff1,sff2;
  Curve c;
  Scalar k1,k2;
  Point q;
  int rv;

  q = ReturnUDPoint(v1);
  if ( !dGetSFF(v1->externalData,"Point.sff", StdFrame(SpaceOf(q)),&sff1)){
    fprintf(stderr,"dBHS: vertex missing SFF.  Exiting.\n");
    exit(1);
  }

  q = ReturnUDPoint(v2);
  if ( !dGetSFF(v2->externalData,"Point.sff", StdFrame(SpaceOf(q)),&sff2)){
    fprintf(stderr,"dBHS: vertex missing SFF.  Exiting.\n");
    exit(1);
  }

  rv = deBoorHolligSabin(ReturnUDPoint(v1),
			 ReturnUDNormal(v1),
			 sff1,
			 ReturnUDPoint(v2),
			 ReturnUDNormal(v2),
			 sff2,
			 &c);

  *p1 = c.cp[1];
  *p2 = c.cp[2];

  return rv;
}

int dBHSTangents(v1,v2,t1,t2)
Vertex* v1;
Vertex* v2;
Vector* t1;
Vector* t2;
{
  Point p1,p2;

  if ( dBHS(v1,v2,&p1,&p2) ) {
    *t1 = SVMult(3.0, PPDiff(p1, ReturnUDPoint(v1)));
    *t2 = SVMult(3.0, PPDiff(ReturnUDPoint(v2), p2));
    return 1;
  } else {
    return 0;
  }
}
